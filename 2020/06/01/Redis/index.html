
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexo || Redis 基础</title>
    <meta name="author" content="John Doe">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Hexo</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Redis 基础 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2020/6/1
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java" style=color:#00bcd4>
                    Java
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="零、NoSQL概述"><a href="#零、NoSQL概述" class="headerlink" title="零、NoSQL概述"></a>零、NoSQL概述</h1><p>Not Only SQL 不仅仅是SQL，泛指非关系型数据库，随着Web2.0互联网的诞生，传统的关系型数据库很难对付。尤其是超大规模的高并发的社区。</p>
<p>关系型数据库：表格，行和列 （POI可以操作Excel）</p>
<p>非关系型数据库：很多的数据类型如个人信息、社交网络、地理位置。这些数据类型的储存不需要一个固定的格式！不需要多余的操作就可以横向扩展。Map&lt;String,Object&gt;可存万事万物，使用键值对来控制</p>
<h2 id="0-1-NoSQL特点"><a href="#0-1-NoSQL特点" class="headerlink" title="0.1 NoSQL特点"></a>0.1 NoSQL特点</h2><p>解耦！</p>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展）</li>
<li>大数据量高性能(Redis 一秒写8万次，读取11万次 ，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高)</li>
<li>数据类型是多样型的。不需要事先设计数据库，随去随用</li>
</ol>
<blockquote>
<p>传统RDBMS和NoSQL的关系</p>
</blockquote>
<p>传统的RDBMS：</p>
<ul>
<li>结构化组织</li>
<li>SQL</li>
<li>数据和关系都存在单独的表 row col</li>
<li>操作，数据定义语言</li>
<li>严格的一致性 ACID</li>
<li>基础的事务操作</li>
<li>…</li>
</ul>
<p>NoSQL：</p>
<ul>
<li>不仅仅是数据</li>
<li>没有固定的查询语言</li>
<li>键值对存储，列存储，文档存储，图形数据库(社交关系)</li>
<li>最终一致性，CAP定理和BASE理论(异地多活)  —&gt; 初级架构师</li>
<li>高性能，高可用，高可扩展性</li>
</ul>
<blockquote>
<p>了解</p>
</blockquote>
<p>3V + 3高</p>
<p>大数据时代的3V：</p>
<ul>
<li>主要是描述问题的</li>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ul>
<p>大数据时代的3高：</p>
<ul>
<li>高并发</li>
<li>高可拓 </li>
<li>高性能</li>
</ul>
<h2 id="0-2-阿里巴巴演进分析"><a href="#0-2-阿里巴巴演进分析" class="headerlink" title="0.2 阿里巴巴演进分析"></a>0.2 阿里巴巴演进分析</h2><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829125500862.png" alt="image-20210829125500862"></p>
<p>敏捷开发、极限编程</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829131251178.png" alt="image-20210829131251178"></p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829131613382.png" alt="image-20210829131613382"></p>
<p>大型互联网应用问题：</p>
<ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构。</li>
<li>数据要改造，需要大面积改造</li>
</ul>
<p>解决问题：</p>
<ul>
<li>统一数据服务层</li>
</ul>
<h2 id="0-3-NoSQL的四大分类"><a href="#0-3-NoSQL的四大分类" class="headerlink" title="0.3 NoSQL的四大分类"></a>0.3 NoSQL的四大分类</h2><blockquote>
<p>KV键值对</p>
</blockquote>
<ul>
<li>新浪： <strong>Redis</strong></li>
<li>美团：Redis+Tair</li>
<li>阿里、百度：Redis + memecache</li>
</ul>
<blockquote>
<p>文档型数据库(BSON格式)</p>
</blockquote>
<ul>
<li>MongoDB<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li>
<li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品，是非关系型数据库中功能最丰富，最像关系型数据库的</li>
</ul>
</li>
<li>ConchDB</li>
</ul>
<blockquote>
<p>列存储数据库</p>
</blockquote>
<ul>
<li><strong>HBase</strong></li>
<li>分布式文件系统</li>
</ul>
<blockquote>
<p>图关系数据库</p>
</blockquote>
<ul>
<li>不是存图形的，放到是关系，比如：朋友圈社交网络，广告推荐。</li>
<li><strong>Neo4j</strong> ， InfoGrid;</li>
</ul>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829133547319.png" alt="image-20210829133547319"></p>
<h2 id="0-4-文档内容："><a href="#0-4-文档内容：" class="headerlink" title="0.4 文档内容："></a>0.4 文档内容：</h2><ul>
<li>NoSQL讲解</li>
<li>阿里巴巴架构演进</li>
<li>NoSQL数据模型</li>
<li>NoSQL四大分类</li>
<li>CAP</li>
<li>BASE</li>
<li>五大基本数据类型<ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Hash</li>
<li>Zset</li>
</ul>
</li>
<li>三种特殊数据类型<ul>
<li>geo</li>
<li>hyperloglog</li>
<li>bitmap</li>
</ul>
</li>
<li>Redis配置</li>
<li>Redis持久化<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
</li>
<li>Redis事务操作 -包含CAP和BASE</li>
<li>Redis实现订阅发布</li>
<li>Redis主从复制</li>
<li>Redis哨兵模式：现在公司中所有的集群都在用哨兵模式</li>
<li>缓存穿透及解决方案</li>
<li>缓存击穿及解决方案</li>
<li>缓存雪崩及解决方案</li>
<li>基础API之Jedis详解 ( Redis 底层)</li>
<li>SpringBoot集成Redis操作</li>
<li>Redis分析</li>
</ul>
<h1 id="一、Redis-入门"><a href="#一、Redis-入门" class="headerlink" title="一、Redis 入门"></a>一、Redis 入门</h1><h2 id="1-1-Redis概述"><a href="#1-1-Redis概述" class="headerlink" title="1.1 Redis概述"></a>1.1 Redis概述</h2><blockquote>
<p>Redis是什么?</p>
</blockquote>
<p>Redis ( <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，远程字典服务</p>
<p>是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的APl。</p>
<blockquote>
<p>Redis能干什么</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失，所以持久化很重要(RDB、AOF)</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量！）</li>
<li>….</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
<li>…</li>
</ol>
<blockquote>
<p>学习中需要用到的东西</p>
</blockquote>
<ol>
<li>Redis官网：redis.io </li>
<li>Redis中文网：redis.cn</li>
</ol>
<p>注意！Windows在Github上下载，但是已经停更很久了。</p>
<p>Redis建议在Linux上学习和使用</p>
<h2 id="1-2-Windwos安装"><a href="#1-2-Windwos安装" class="headerlink" title="1.2 Windwos安装"></a>1.2 Windwos安装</h2><ol>
<li>下载：<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></li>
<li>解压到电脑上的环境目录下即可</li>
<li>开启Redis，开启服务即可<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829152823131.png" alt="image-20210829152823131"></li>
<li>默认端口为6379<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829152843479.png" alt="image-20210829152843479"></li>
<li>使用Redis客户端连接Redis<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829152929245.png" alt="image-20210829152929245"></li>
<li>连接成功检验<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829153105031.png" alt="image-20210829153105031"></li>
<li></li>
</ol>
<p>虽然Windows 版本的Redis操作十分简单，但Redis官方推荐我们使用Linux！ </p>
<h2 id="1-3-Linux安装"><a href="#1-3-Linux安装" class="headerlink" title="1.3 Linux安装"></a>1.3 Linux安装</h2><ol>
<li><p>官网下载安装包</p>
</li>
<li><p>解压安装包，程序一般放在 /otp目录下<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829163352523.png" alt="image-20210829163352523"></p>
</li>
<li><p>进入解压后的文件夹，可以看到redis的配置文件：redis.conf</p>
</li>
<li><p>安装基本的环境安装</p>
<pre><code class="bash">yum install gcc-c++
</code></pre>
<pre><code class="bash">make
</code></pre>
<p>检查make是否讲所需环境已经装配完成</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829163939626.png" alt="image-20210829163939626"></p>
</li>
</ol>
<p>5.redis的默认安装路径： /usr/local/bin/ </p>
<p>6.将redis配置备份一份，复制到bin目录下的一个自命名的文件夹内</p>
<pre><code class="bash">mkdir SkyFroopConfig
</code></pre>
<pre><code class="bash">cp /opt/redis-6.2.5/redis.conf SkyFroopConfig/
</code></pre>
<p>7.启动：</p>
<ul>
<li>默认不是后台启动，修改配置文件：<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829170034641.png" alt="image-20210829170034641">改为yes</li>
<li>通过指定的配置文件启动服务：运行redis-server SkyFroopConfig/redis.conf</li>
<li>运行redis-cli -p 端口号 运行</li>
<li>测试连接</li>
</ul>
<p>8.查看Redis的服务是否开启</p>
<pre><code class="bash">ps -ef|grep redis
</code></pre>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829170710229.png" alt="image-20210829170710229"></p>
<p>9.关闭Redis服务</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829170748046.png" alt="image-20210829170748046"></p>
<p>10.后面会使用单机多Redis启动集群测试！</p>
<h2 id="1-4-测试性能"><a href="#1-4-测试性能" class="headerlink" title="1.4 测试性能"></a>1.4 测试性能</h2><p><strong>redis-benchmark</strong>是一个压力测试工具</p>
<p>redis-benchmark 命令</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829171112405.png" alt="image-20210829171112405"></p>
<pre><code class="bash"># 测试 100个并发连接 10万个请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
</code></pre>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829183347452.png" alt="image-20210829183347452"></p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829183537841.png" alt="image-20210829183537841"></p>
<blockquote>
<p>如何查看分析</p>
</blockquote>
<ol>
<li>10w并发在2.20 秒完成</li>
<li>100个并发客户端</li>
<li>每次只写三个字节</li>
<li>只有一台服务器在处理请求(单机性能)</li>
<li>每秒处理45351个请求</li>
</ol>
<h2 id="1-5-基础知识"><a href="#1-5-基础知识" class="headerlink" title="1.5 基础知识"></a>1.5 基础知识</h2><p>Redis默认有16个数据库</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829183752843.png" alt="image-20210829183752843"></p>
<p>默认使用的是第0个，可以使用Select进行切换 Select [0,15]</p>
<h3 id="部分数据库操作语法"><a href="#部分数据库操作语法" class="headerlink" title="部分数据库操作语法"></a>部分数据库操作语法</h3><pre><code class="bash">SELECT [index] #选择第几个数据库
DBSIZE # 数据库内容大小
keys * # 查看数据库所有的key
flushdb # 清空当前库
flushall # 清空所有库
</code></pre>
<blockquote>
<p>Redis是单线程的</p>
</blockquote>
<p>Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，可以使用单线程实现，就是用单线程了。</p>
<p>Redis是 ANSI C语言写的，官方数据为100000+的APS，完全这个不比同样使用Key-Vale的Memecache差</p>
<p><strong>那么Redis是单线程为什么还这么快？</strong></p>
<p>误区：</p>
<ol>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程(CPU)一定比单线程效率高？ 多线程CPU上下文会切换会耗时。速度：CPU &gt; 内存 &gt; 硬盘</li>
</ol>
<p>核心：</p>
<p>Redis是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的。对于内存系统来说，如果没有上下文切换，效率就是最高的。多次读写都是在一个CPU上的，在内存情况下，这就是最佳方案。</p>
<h1 id="二、Redis的数据类型"><a href="#二、Redis的数据类型" class="headerlink" title="二、Redis的数据类型"></a>二、Redis的数据类型</h1><h2 id="2-1-五大基本数据类型"><a href="#2-1-五大基本数据类型" class="headerlink" title="2.1 五大基本数据类型"></a>2.1 五大基本数据类型</h2><blockquote>
<p>官网文档</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210829185444157.png" alt="image-20210829185444157"></p>
<p>即Redis是一个开源（BSD许可)的，内存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。它支持多种类型的数据结构，如字符串( strings )，散列( hashes )，列表( lists )，集合( sets )，有序集合( sorted sets ）与范围查询，bitmaps ，hyperloglogs和地理空间 ( geospatial）索引半径查询。Redis 内置了 复制( replication )，LUA脚本( Lua scripting )，LRU驱动事件( LRU eviction )，事务( transactions）和不同级别的磁盘持久化( persistence)，并通过Redis哨兵( Sentinel)和自动分区( Cluster )提供高可用性( high availability )。</p>
<h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><pre><code class="bash">EXISTS [value] # 是否存在某个值
MOVE [key-value] # 移除某个值
EXPIRE [key] [seconds] # 设置有效时间
TTL [key] # 查看key的剩余有效时间
TYPE [key] # 查看当前key的类型
</code></pre>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><pre><code class="bash">SET [key-value] # 设置值
GET [key] # 获得值
APPEND [key] [&quot;String&quot;] # 在key字段后追加字符串,如果这个字符串不存在则会新建,相当于SET

STRLEN [key] # key字符串的长度
INCR [key] # 自增1
DECR [key] # 自减1
INCRBY [key] [value] # 令key自增步长为value

GETRANGE [key] [start] [end] # 取key的start到end区间的值(闭区间)，end为-1时，就是全部值
SETRANGE [key] [offset] [value] # 从offset后改成value，替换指定位置开始的字符串

SETEX [key] [seconds] [value]# 设置过期时间，过期时间为seconds
SETNX [key-value] # 如果不存在再设置 , 在分布式锁中常常会使用，如果key不存在才会创建，否则失败
MSET [key-value ...] # 一次性设置多个值
MGET [key ...] # 一次获取多个值
MSETNX [key-value ...] # 是一个原子性的操作，要么一起成功，要么一起失败 

####对象如何储存
SET user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1对象，值为JSON字符串来保存一个对象

#### 这里的key是一个巧妙的设计 : user:&#123;id&#125;:&#123;filed&#125;
MSET user:1:name zhangsan
MSET user:1:age 2

#组合命令
GETSET [key-value] # 先get再set.如果存在值，获取原来的值并设置新的值
</code></pre>
<p>使用场景：value除了是字符串之外，还可以是数字</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p>在Redis里面，可以把List做成栈、队列、阻塞队列</p>
<p><strong>所有的list命令基本都是L开头的</strong></p>
<pre><code class="bash">LPUSH [key] [element ...] # 放入一个或多个值，插入到列表的头部
RPUSH [key] [element ...] # 放入一个或多个值，插入到列表的尾部
LRANGE [key] [start] [stop] # 取start到stop的值，stop为-1时，取全部值
LSET [key] [index] [value] # 将下标为index的值替换为value，如果key中的index不存在，则ERROR，可以用其修改某个值，不能插入值！
Linsert [key] [BEFORE|AFTER] [pivot] [value] # 在值为&quot;pivot&quot;的(前面|后面)添加一个value 

LPOP [key] [count] # 移除从头部起第count个值，缺省count时默认第一个值
RPOP [key] [count] # 移除从尾部起第count个值，缺省count时默认第一个值
LREM [key] [count] [element] # 移除指定的值。移除key中的count个element值。

LINDEX [key] [index] # 通过下标获得list中的某一个值
LLEN # 获取list长度

TRIM [key] [start] [stop] # 修剪key从start到stop的值，可以做一个截断操作，截取指定的区间内的值，但是这个list已经被改变了，只剩下截取的元素了

RPOPLPUSH [source] [destination] # 将source的尾部第一个值，放入新的列表destination的头部
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>实际上是一个链表，before Node ，left，right都可以插入值</p>
<p>如果key不存在就创建新的链表</p>
<p>如果key存在就新增内容</p>
<p>如果移除了key，所有的value都会消失</p>
<p>用途：</p>
<ul>
<li>消息队列：Lpush Rpop  </li>
<li> 栈 ： Lpush Lpop</li>
</ul>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p>set中的值是不能重复的</p>
<pre><code class="bash">Sadd [key] [member] # set集合中插入member

Srem [key] [member] # 移除集合key中的member值
Spop [key] # 随机删除集合中的元素
Smove [source] [destination] [element] # 将element值从集合source移动到集合destination

SMEMBERS [key] #查看key的所有值
SISMEMBER [key] [member] # 查看key中是否包含member值
SRANDMEMBER [key] [value] # 随机抽出集合key中value个元素

Scard [key] # 获取集合key中的元素个数

#### 微博、B站，共同关注！(并集)
#### 数字集合类
# - 差集
# - 交集
# - 并集
SDIFF [key ...] # key1 key2 ... 的差集
SINTER [key ...] # key1 key2 ... 的交集。 共同好友的实现
SUNION [key ...] # key1 key2 ... 的并集
</code></pre>
<blockquote>
<p>用途</p>
</blockquote>
<p>共同关注的实现：将用户所有关注的人放在一个set集合中，将它的粉丝也放在一个集合中</p>
<p>共同关注，共同爱好，二度好友，推荐好友(六度分隔理论)</p>
<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p>Map集合，key-map 这个值是一个map集合</p>
<pre><code class="bash">HSET [key] [field-value] # 在哈希集合key中放入字段field及其值value
HGET [key] [field] # 取出哈希集合key中的field字段
HMSET [key] [field] [value] [filed value ...] # set多个key-value
HMGET [key] [field ...] # 获取哈希集合key的多个field字段
HGETALL # 获取全部的数据

HDEL [key] [field ...] # 删除哈希集合key中的field字段
HLEN [key] # 获取哈希集合key的字段数量
HEXISTS [key] [field] # 判断哈希集合key中是否存在field字段
HKEYS [key] # 只获得所有的field
HVALS [key] # 只获得所有的value

####Hash的自增 自减
HINCRBY [key] [field] [increment] # 哈希集合key的field字段自增increment

HSETNX [key] [field] [value] # 如果不存在则可以设置，如果存在则不能设置
</code></pre>
<blockquote>
<p>应用</p>
</blockquote>
<p>变更的数据user name age等尤其是用户信息制类的，经常变动的信息！</p>
<p>Hash更适合对象的存储</p>
<p>String更适合字符串存储</p>
<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><p>在Set的基础上，增加了一个值</p>
<pre><code class="bash">Zadd [key] [NX|XX] [GT|LT] [CH] [INCR] [score member ...] # 
ZRANGEBYSCORE [key] [min] [max] [withscores] [limit offset count] #
#inf 代表无穷
ZRANGEBYSCORE [key] -inf +inf # 显示全部用户，从小到大
ZRANGEBYSCORE [key] -inf +inf withscores # 显示全部用户，从小到大,并附带score值
ZREVRANGE [key] [start] [stop] [withscores] # 排序
ZREVRANGE [key] 0 -1 [withscores] # 从大到小
Zrem [key] [member ...] # 移除有序集合key中的member元素
Zcard [key] # 获取有序集合key中的个数

Zcount [key] [min] [max] # 获取Key中指定区间的成员数量
</code></pre>
<blockquote>
<p>案例思路</p>
</blockquote>
<p>set 排序 存储班级成绩表，工资表排序</p>
<p>普通消息：1.重要消息 2.带权重进行判断</p>
<p>排行榜应用Top榜</p>
<h2 id="2-2-三大特殊数据类型"><a href="#2-2-三大特殊数据类型" class="headerlink" title="2.2 三大特殊数据类型"></a>2.2 三大特殊数据类型</h2><h3 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h3><blockquote>
<p>用途</p>
</blockquote>
<p>Redis的Geo：可以推算地理位置的信息，两地之间的距离，方圆几里内的人 </p>
<ul>
<li><p>朋友的定位</p>
</li>
<li><p>附近的人</p>
</li>
<li><p>打车距离计算</p>
</li>
</ul>
<p>可以查询一些测试数据</p>
<pre><code class="bash"># 添加地理位置，规则：两级无法直接添加，我们一般会下载城市数据，直接通过Java程序一次性导入
# 参数: key 纬度 经度 名称
GEOADD
# 获取指定的城市的精度和维度
# 参数: key element
GEOPOS
# m：米  km：千米  mi：英里 ft：为英尺。
# 参数: [key] [element1] [element2] [unit]
GEODIST
# 以一个经纬度为中心，半径radius内的元素
# 参数: key 经度 纬度 radius withdist(显示到中心距离的位置) withcoord(显示他人的定位信息) count
GEORADIUS
# 以一个元素坐标为中心，半径radius内的元素
# 参数: key element radius withdist withcoord count
GEORADIUSBYMEMBER
# 了解,返回11个字符的Geohash字符串。将二位的经纬度转换为以为的字符串，如果两个字符串越接近，那么距离越近
GEOHASH
</code></pre>
<blockquote>
<p>GEO底层实现原理其实就是Zset，我们可以使用Zset命令操作GEO</p>
</blockquote>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>什么是基数</p>
</blockquote>
<p>A{1,3,5,7,8,9,}  </p>
<p>B{1,3,5,7,8}</p>
<p>基数(不重复的元素)： = 5 </p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis Hyperloglog基数统计的算法!</p>
<p>网页的UV ( 一个人访问一个网站多次,但是还是算作一个人! )<br>传统的方式，set 保存用户的id ,然后就可以统计set中的元素数量作为标准怕段</p>
<p>这个方式如果保存大量的用户id ,就会比较麻烦!我们的目的是为了计数，而不是保存用户Id</p>
<pre><code class="bash">PFadd [key] [element ...] # 加入元素
PFCOUNT [key] # 统计key中的基数数量
PFMERGE [key1] [key2] [newkey] # 合并key1和key2为key3
</code></pre>
<p>但Hyperloglog不会特别精确。精确率在81%左右</p>
<p>原理：HyperLogLog基于概率论中伯努利试验并结合了极大似然估算方法，并做了分桶优化。</p>
<p>Redis中，12KB的桶，共16384(2^14^)个桶，每个桶6bit</p>
<p>64位的bit串，14bit定位桶，假设</p>
<blockquote>
<p>用途</p>
</blockquote>
<p>允许一定的容错</p>
<ul>
<li>网页UV 计数<ol>
<li>转化为一个比特串 hash函数</li>
<li>分桶(大的位数组) 如，100100 00 -&gt; 0号桶  100100 11-&gt; 3号桶</li>
<li></li>
</ol>
</li>
</ul>
<p>如果不允许容错，就要使用set或其他自定义的数据类型。</p>
<p>UV（独立访客），需要去重：UV是网站的用户访问量，访问您网站的一台电脑客户端为一个访客</p>
<p>PV：即页面浏览量，或点击量；用户每1次对网站中的每个网页访问均被记录1次。</p>
<h3 id="Bitmap-位存储"><a href="#Bitmap-位存储" class="headerlink" title="Bitmap(位存储)"></a>Bitmap(位存储)</h3><blockquote>
<p>用途</p>
</blockquote>
<p>统计用户信息：活跃、不活跃；登录、未登录；365天的打卡等，涉及到两个状态的都可以使用。</p>
<p>Bitmap位图，数据结构！都是操作二进制位来进行记录，只有0和1两个状态</p>
<pre><code class="bash">setbit
getbit
bitcount
</code></pre>
<h1 id="三、Redis事务"><a href="#三、Redis事务" class="headerlink" title="三、Redis事务"></a>三、Redis事务</h1><p><em>MySQL：ACID 其中，原子性：要么同时成功，要么同时失败</em></p>
<p><strong>Redis的单条指令可以保证原子性，但是事务不保证原子性</strong></p>
<p><strong>Redis事务没有隔离级别的概念</strong> ：所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行。</p>
<p>Redis事务的本质：一组命令的集合 ！一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性 –&gt;执行一些列的命令</p>
<h2 id="3-1-事务"><a href="#3-1-事务" class="headerlink" title="3.1 事务"></a>3.1 事务</h2><blockquote>
<p>正常执行事务</p>
</blockquote>
<p>Redis的事务：</p>
<ul>
<li><p>开启事务( Multi )</p>
</li>
<li><p>命令入队( … )</p>
</li>
<li><p>执行事务( Exec )</p>
</li>
<li><p>事务结束</p>
</li>
</ul>
<blockquote>
<p>放弃事务</p>
</blockquote>
<p>DISCARD</p>
<p>放弃后，事务中的队列中的命令都不会执行。</p>
<blockquote>
<p>编译型异常(代码有问题！命令有错) </p>
</blockquote>
<p>事务中所有的命令都不会被执行</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830200701579.png" alt="image-20210830200701579"></p>
<blockquote>
<p>运行时异常(1/0)</p>
</blockquote>
<p>如果事务队列中存在语法型错误，那么执行命令的时候，其他命令可以正常执行</p>
<p>，错误命令抛出异常。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830201004303.png" alt="image-20210830201004303"></p>
<p>虽然第一条命令报错了，但是依旧正常执行成功了。</p>
<h2 id="3-2-乐观锁"><a href="#3-2-乐观锁" class="headerlink" title="3.2 乐观锁"></a>3.2 乐观锁</h2><blockquote>
<p>MySQL的锁</p>
</blockquote>
<p><strong>悲观锁</strong> ：认为什么时候都会出问题，无论做什么都会加锁。</p>
<p><strong>乐观锁</strong> ：认为什么时候都不会出问题，所以不会上锁。更新数据的时候去判断一下，在此期间是否有人修改过数据，version字段。获取version，更新的时候比较version。</p>
<blockquote>
<p>Redis监控</p>
</blockquote>
<p>正常执行成功：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830201652688.png" alt="image-20210830201652688"></p>
<p>测试多线程修改值，使用watch可以当作Redis的乐观锁操作</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830202701786.png" alt="image-20210830202701786"></p>
<p>如果修改失败，获取最新的值即可</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830202722745.png" alt="image-20210830202722745"></p>
<blockquote>
<p> 面试常问</p>
</blockquote>
<p>Redis可以写乐观锁</p>
<h1 id="四、Jedis"><a href="#四、Jedis" class="headerlink" title="四、Jedis"></a>四、Jedis</h1><p>使用Java操作Redis</p>
<blockquote>
<p>Jedis是Redis官方推荐的Java连接开发工具，使用Java操作Redis的中间件，如果使用Java操作Redis，就一定要对Jedis十分的熟悉</p>
</blockquote>
<p>1、导入依赖</p>
<pre><code class="xml">&lt;!--        Jedis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        fastjson--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.76&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、编码测试</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
<pre><code class="java">//1. new Jedis对象
Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
//Jedis所有的命令就是之前的Redis指令
</code></pre>
<h2 id="4-1-常用API"><a href="#4-1-常用API" class="headerlink" title="4.1 常用API"></a>4.1 常用API</h2><ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Hash</li>
<li>Zset</li>
</ul>
<p>同前方指令</p>
<h2 id="4-2-通过Jedis理解事务"><a href="#4-2-通过Jedis理解事务" class="headerlink" title="4.2 通过Jedis理解事务"></a>4.2 通过Jedis理解事务</h2><pre><code class="java">//开启事务
Transaction multi = jedis.multi();

try &#123;
    multi.set(&quot;user1&quot;,result);//测试命令1
    multi.set(&quot;user2&quot;,result);//测试命令2
    multi.exec();//执行事务
&#125;catch (Exception e)&#123;
    multi.discard();//放弃事务
    e.printStackTrace();
&#125;finally &#123;
    jedis.close();//关闭连接
&#125;
</code></pre>
<h1 id="五、SpringBoot整合Redis"><a href="#五、SpringBoot整合Redis" class="headerlink" title="五、SpringBoot整合Redis"></a>五、SpringBoot整合Redis</h1><p>SpringData也是和SpringBoot齐名的项目</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210830221242874.png" alt="image-20210830221242874"></p>
<p>==说明：在SpringBoot2.x之后，原来使用的jedis被替换成了lettuce==</p>
<ul>
<li>jedis ： 采用的直连，多个线程操作的话是不安全的，如果想要避免不安全的，使用jedis pool连接池。更像BIO模式</li>
<li>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况，可以减少线程数量，更像Nio模式</li>
</ul>
<h2 id="5-1-源码解析"><a href="#5-1-源码解析" class="headerlink" title="5.1 源码解析"></a>5.1 源码解析</h2><ul>
<li><p>SpringBoot所有的配置类，都有一个自动配置类 ：<strong>RedisAutoConfiguration</strong></p>
</li>
<li><p>自动配置类都会绑定一个properties配置文件 ：<strong>RedisProperties</strong></p>
</li>
</ul>
<pre><code class="java">@Bean
@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)//我们可以自定义一个RedisTemplate来替换这个默认的
@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
    //默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！
    //两个泛型都是Object的类型，后面使用需要强制转换成&lt;String,Object&gt;
    RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
&#125;

@Bean
@ConditionalOnMissingBean //由于String是Redis中最常使用的类型，所以单独提出来了一个Bean
@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
&#125;
</code></pre>
<p><em>ConditionalOnMissingBean:当这个方法不存在时，使用这里的方法</em></p>
<h2 id="5-2-整合测试"><a href="#5-2-整合测试" class="headerlink" title="5.2 整合测试"></a>5.2 整合测试</h2><p>1、导入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置文件</p>
<pre><code class="yaml">spring:
  redis:
    host: 127.0.0.1
    port: 6379
</code></pre>
<p>3、Junit测试</p>
<pre><code class="java">@Test
void contextLoads() &#123;
    /* redisTemplate 操作不同数据类型的API*/
    //opsForValue 操作字符串 类似String
    //opsForList 操作List 类似List
    //....
    //每一个操作对应一个数据类型 opsForXxx
    redisTemplate.opsForValue();

    /* 获取Redis连接 */
    RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
    //        connection.flushDb();
    //        connection.flushAll();

&#125;
</code></pre>
<p>==在开发中很少使用这些原生的方式去编写代码，通常写一个RedisUtils写一个工具类.==</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831093100444.png" alt="image-20210831093100444"></p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831093356666.png" alt="image-20210831093356666"></p>
<p>默认的序列化方式是JDK序列化，我们可能会使用Json来序列化。</p>
<p>所有对象也需要序列化，否则无法进行序列化处理。</p>
<p><strong>所以我们需要自定义一个配置类</strong></p>
<h2 id="5-3-自定义RedisTemplate"><a href="#5-3-自定义RedisTemplate" class="headerlink" title="5.3 自定义RedisTemplate"></a>5.3 自定义RedisTemplate</h2><pre><code class="java">package com.skyfroop.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.net.UnknownHostException;

/**
 *
 * @Description TODO RedisConfig 固定模板,可直接使用
 * @Create: by SkyFroop
 */
@Configuration
public class RedisConfig &#123;

    @Bean
    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException&#123;
        //为了开发方便，一般直接使用&lt;String,Object&gt;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);

        // Json序列化配置
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY)
                    .enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        //String的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        //key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        //Hash的key采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        //value序列化方式采用jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        //Hash的value序列化方式采用Jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);

        template.afterPropertiesSet();// 生效配置

        return template;
    &#125;

&#125;
</code></pre>
<h2 id="5-4-RedisUtil工具包-当前版本仅包含常用命令"><a href="#5-4-RedisUtil工具包-当前版本仅包含常用命令" class="headerlink" title="5.4 RedisUtil工具包(当前版本仅包含常用命令)"></a>5.4 RedisUtil工具包(当前版本仅包含常用命令)</h2><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 *
 * @Description TODO Redis工具类
 * @Create: Power By SkyFroop(HAN XIAOJIE)
 *
 */
@Component
public final class RedisUtil &#123;
    @Autowired
    private RedisTemplate&lt;String,Object&gt; redisTemplatel;

    //====================================common====================================

    /**
     * 指定缓存失效时间
     * @param key 键
     * @param time 时间(秒)
     * */
    public boolean expire(String key,long time)&#123;
        try&#123;
            if(time &gt; 0)&#123;
                redisTemplatel.expire(key,time, TimeUnit.SECONDS);
            &#125;
            return true;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 根据key 获取过期时间
     * @param key 键 NOT NULL
     * @return 时间(秒) 返回0代表永久有效
     * */
    public long getExpire(String key)&#123;
        return redisTemplatel.getExpire(key,TimeUnit.SECONDS);
    &#125;

    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false 不存在
     * */
    public boolean hasKey(String key)&#123;
        try &#123;
            return redisTemplatel.hasKey(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 删除缓存
     * @param key one or more...
     * */
    public void del(String ...key)&#123;
        if (key != null &amp;&amp; key.length &gt; 0)&#123;
            if(key.length == 1)&#123;
                redisTemplatel.delete(key[0]);
            &#125;else&#123;
                redisTemplatel.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));
            &#125;
        &#125;
    &#125;

    //====================================String====================================

    /**
     * 普通缓存获取
     * @param key 键
     * @return value
     * */
    public Object get(String key)&#123;
        return key == null ? null : redisTemplatel.opsForValue().get(key);
    &#125;

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true 成功 false 失败
     * */
    public boolean set(String key,Object value)&#123;
        try &#123;
            redisTemplatel.opsForValue().set(key,value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 普通缓存放入并设置时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒) time 应大于0，如果time小于等于0将设置无暇去你
     * @return true 成功 false 失败
     * */
    public boolean set(String key,Object value,long time)&#123;
        try &#123;
            if (time &gt; 0)&#123;
                redisTemplatel.opsForValue().set(key,value,time,TimeUnit.SECONDS);
            &#125;else &#123;
                set(key,value);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 单调递增
     * @param key 键
     * @param delta 步长
     * */
    public long incr(String key,long delta)&#123;
        if (delta &lt; 0)&#123;
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        &#125;
        return redisTemplatel.opsForValue().increment(key,delta);
    &#125;

    /**
     * 单调递减
     * @param key 键
     * @param delta 步长
     * */
    public long decr(String key,long delta)&#123;
        if (delta &lt; 0)&#123;
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        &#125;
        return redisTemplatel.opsForValue().decrement(key,delta);
    &#125;

    //==================================== Map ====================================

    /**
     * HashGet
     * @param key 键 NOT NULL
     * @param item 项 NOT NULL
     * */
    public Object hget(String key,String item)&#123;
        return redisTemplatel.opsForHash().get(key,item);
    &#125;

    /**
     * 获取HashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     * */
    public Map&lt;Object,Object&gt; hmget(String key)&#123;
        return redisTemplatel.opsForHash().entries(key);
    &#125;

    /**
     * HashSet
     * @param key 值
     * @param map 对应多个键值
     * */
    public boolean hmset(String key,Map&lt;String,Object&gt; map)&#123;
        try &#123;
            redisTemplatel.opsForHash().putAll(key,map);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * HashSet 并设置过期时间
     * @param key 值
     * @param map 对应多个键值
     * @param time 时间(秒)
     * */
    public boolean hmset(String key,Map&lt;String,Object&gt; map,long time)&#123;
        try &#123;
            redisTemplatel.opsForHash().putAll(key,map);
            if(time&gt;0)&#123;
                expire(key,time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 向一张Hash放入数据,如果不存在将创建数据
     * @param key 键
     * @param item 项
     * @param value 值
     * */
    public boolean hset(String key,String item,Object value)&#123;
        try &#123;
            redisTemplatel.opsForHash().put(key,item,value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 向一张Hash放入数据,如果不存在将创建数据,同时设置过期时间
     * @param key 键
     * @param item 项
     * @param value 值
     * @param time 时间(秒) 注意：如果已存在的Hash表有时间,这里将会是替换原有时间
     * */
    public boolean hset(String key,String item,Object value,long time)&#123;
        try &#123;
            redisTemplatel.opsForHash().put(key,item,value);
            if (time &gt; 0)&#123;
                expire(key,time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 删除Hash中的值
     *
     * @param key 键 NOT NULL
     * @param item 项 one or more NOT NULL
     * */
    public void hdel(String key ,Object... item)&#123;
        redisTemplatel.opsForHash().delete(key,item);
    &#125;

    /**
     * 判断Hash中是否有该项的值
     * @param key 键
     * @param item 项
     * */
    public boolean hHasKey(String key,String item)&#123;
        return redisTemplatel.opsForHash().hasKey(key,item);
    &#125;

    /**
     * Hash 单调递增 如果不存在，就会创建一个，并把新增后的值返回
     * @param key 键
     * @param item 项
     * @param by 步长
     * */
    public double hincr(String key,String item,double by)&#123;
        return redisTemplatel.opsForHash().increment(key,item,by);
    &#125;

    /**
     * Hash 单调递减
     * @param key 键
     * @param item 项
     * @param by 步长
     * */
    public double hdecr(String key,String item,double by)&#123;
        return redisTemplatel.opsForHash().increment(key,item,-by);
    &#125;

    //==================================== Set ====================================

    /**
     * 根据key获取Set所有值
     * @param key 键
     * */
    public Set&lt;Object&gt; sGet(String key)&#123;
        try &#123;
            return redisTemplatel.opsForSet().members(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;

    /**
     * 从Set中查询是否存在value
     * @param key 键
     * @param value 值
     * */
    public boolean sHasKey(String key,Object value)&#123;
        try &#123;
            return redisTemplatel.opsForSet().isMember(key,value);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 将数据放入Set缓存
     * @param key 键
     * @param values 值 one or more
     * @return 成功个数
     * */
    public long sSet(String key,Object... values)&#123;
        try &#123;
            return redisTemplatel.opsForSet().add(key,values);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    /**
     * 将数据放入Set缓存,并设置过期时间
     * @param key 键
     * @param time 时间(秒)
     * @param values 值 one or more
     * @return 成功个数
     * */
    public long sSet(String key,long time,Object... values)&#123;
        try &#123;
            Long count = redisTemplatel.opsForSet().add(key, values);
            if(time &gt; 0)&#123;
                expire(key,time);
            &#125;
            return count;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    /**
     * 获取Set缓存长度
     * @param key 键
     * @return Set缓存长度
     * */
    public long sGetSetSize(String key)&#123;
        try &#123;
            return redisTemplatel.opsForSet().size(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    /**
     * 从Set中移除值为value的项
     * @param key 键
     * @param values 值 one or more
     * @return 移除的个数
     * */
    public long setRemove(String key,Object... values)&#123;
        try &#123;
            return redisTemplatel.opsForSet().remove(key, values);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    //==================================== List ====================================

    /**
     * 获取list缓存的长度
     * @param key 键
     * */
    public long lGetListSize(String key)&#123;
        try &#123;
            return redisTemplatel.opsForList().size(key);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    /**
     * 通过索引获取list中的值
     * @param key 键
     * @param index 索引
     * @Description index &gt;= 0时, 0为表头索引,index &lt; 0时,-1为表尾,-2为到数第二个元素...
     * */
    public Object lGetIndex(String key,long index)&#123;
        try &#123;
            return redisTemplatel.opsForList().index(key,index);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;

    /**
     * 将List放入缓存
     * @param key 键
     * @param value 值
     * */
    public boolean lSet(String key,Object value)&#123;
        try &#123;
            redisTemplatel.opsForList().rightPush(key,value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 将List放入缓存,并设置过期时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * */
    public boolean lSet(String key,Object value,long time)&#123;
        try &#123;
            redisTemplatel.opsForList().rightPush(key,value);
            if (time &gt; 0)&#123;
                expire(key,time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 将List&lt;&gt;放入缓存
     * @param key 键
     * @param value 值
     * */
    public boolean lSet(String key, List&lt;Object&gt; value)&#123;
        try &#123;
            redisTemplatel.opsForList().rightPushAll(key,value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 将List&lt;&gt;放放入缓存,并设置过期时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * */
    public boolean lSet(String key,List&lt;Object&gt; value,long time)&#123;
        try &#123;
            redisTemplatel.opsForList().rightPush(key,value);
            if (time &gt; 0)&#123;
                expire(key,time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 根据索引修改List中的某条数据
     *
     * @param key 键
     * @param index 索引
     * @param value 值
     * */
    public boolean lUpdateIndex(String key,long index,Object value)&#123;
        try &#123;
            redisTemplatel.opsForList().set(key, index, value);
            return true;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return false;
        &#125;
    &#125;

    /**
     * 移除N个值为value
     * @param key 键
     * @param count 移除数量
     * @param value 值
     * @return 移除的个数
     * */
    public long lRemove(String key,long count,Object value)&#123;
        try &#123;
            Long removeCount = redisTemplatel.opsForList().remove(key, count, value);
            return removeCount;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            return 0;
        &#125;
    &#125;

    //==================================== Zset ====================================


    //====================================Geospatial====================================


    //====================================Hyperloglog====================================


    //====================================Bitmap====================================


&#125;
</code></pre>
<h1 id="六、Redis-conf详解"><a href="#六、Redis-conf详解" class="headerlink" title="六、Redis.conf详解"></a>六、Redis.conf详解</h1><p>Redis启动的时候，就通过配置文件来启动。</p>
<blockquote>
<p> <strong>单位</strong></p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831154709474.png" alt="image-20210831154709474"></p>
<ol>
<li>配置文件unit单位对大小写不敏感，拥有这几种单位</li>
</ol>
<blockquote>
<p><strong>包含</strong></p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831154814995.png" alt="image-20210831154814995"></p>
<blockquote>
<p><strong>网络</strong></p>
</blockquote>
<pre><code class="bash">bind 127.0.0.1 -::1 # 绑定IP
protected-mode yes # 保护模式
port 6379 # 端口设置
</code></pre>
<blockquote>
<p><strong>通用</strong>( GENERAL)</p>
</blockquote>
<pre><code class="bash">daemonize yes # 以守护进程的方式运行，默认为no，需要修改为yes
pidfile /var/run/redis_6379.pid # 如果以后台的方式运行(守护进程)，我们就需要指定一个pid文件

#日志
# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably) 生产环境使用
# warning (only very important / critical messages are logged)
loglevel notice
logfile &quot;&quot; # 日志的输出文件名

databases 16 # 数据库的数量，默认是16个
always-show-logo no # 是否显示Redis的Logo
</code></pre>
<blockquote>
<p><strong>快照</strong> ( SNAPSHOTTING )</p>
</blockquote>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件(.rdb ; .aof)</p>
<p>Redis是内存数据库，如果没有持久化，那么数据断电即失</p>
<pre><code class="bash"># 如果3600秒内，如果至少有1个key进行了修改，我们即使进行持久化操作
save 3600 1 
#如果300秒内，如果至少有100个key进行了修改，我们即使进行持久化操作
save 300 100
#如果60秒内，如果至少有10000个key进行了修改，我们即使进行持久化操作
save 60 10000

stop-writes-on-bgsave-error yes # 持久化如果出错，是否需要继续工作
rdbcompression yes # 是否压缩rdb资源(需要消耗一些CPU资源)
rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验
dir ./ # rdb文件默认的保存目录，默认是在当前文件夹下
dbfilename dump.rdb # rdb的默认文件名
</code></pre>
<blockquote>
<p><strong>复制</strong> ( REPLICATION )</p>
</blockquote>
<pre><code class="bash">replicaof &lt;masterip&gt; &lt;masterport&gt; # 从机设置
</code></pre>
<blockquote>
<p><strong>安全</strong> ( SECURITY )</p>
</blockquote>
<pre><code class="bash">requirepass 密码 # 设置密码
##密码设置命令
config set requirepass &quot;密码&quot;
##认证
auth 密码

</code></pre>
<blockquote>
<p><strong>限制</strong> ( CLIENTS )</p>
</blockquote>
<pre><code class="bash">maxclients 10000 # 设置能连接上Redis的最大客户端的数量
</code></pre>
<blockquote>
<p><strong>内存</strong> ( MEMORY MANAGEMENT )</p>
</blockquote>
<pre><code class="bash">maxmemory &lt;bytes&gt; # 最大的内存容量
maxmemory-policy noeviction # 内存达到上限之后的处理策略
                            # 移除一些过期的key 也可能报错
</code></pre>
<p>内存达到上限后的处理策略:</p>
<ul>
<li>volatile-lru:只对设置了过期时间的key进行LRU(默认值)</li>
<li>allkeys-lru :删除1ru算法的key</li>
<li>volatile-random:随机删除即将过期key</li>
<li>allkeys-random:随机删除</li>
<li>volatile-ttl :刮|除即将过期的</li>
<li>noeviction :永不过期,返回错误</li>
</ul>
<blockquote>
<p><strong>APPEND ONLY模式</strong> (AOF)</p>
</blockquote>
<pre><code class="bash">appendonly no # 默认不开启aof模式，默认使用的是rdb方式持久化，在大部分情况下，rdb完全够用
appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字

# appendfsync always # 每次修改都会sync
appendfsync everysec # 每秒执行一次sync,可能会丢失这1秒的数据,默认
# appendfsync no     # 不同步,这个时候操作系统自己同步数据，速度最快
</code></pre>
<h1 id="七、Redis持久化"><a href="#七、Redis持久化" class="headerlink" title="七、Redis持久化"></a>七、Redis持久化</h1><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能!</p>
<p>==面试和工作，持久化都是重点==</p>
<ul>
<li>AOF :( append only file )持久化以独立日志的方式记录每次写命令，并在 Redis 重启时在重新执行 AOF 文件中的命令以达到恢复数据的目的。AOF 的主要作用是解决数据持久化的实时性。</li>
<li>RDB :把当前 Redis 进程的数据生成时间点快照( point-in-time snapshot ) 保存到存储设备的过程。</li>
</ul>
<h2 id="7-1-RDB-Redis-DateBase"><a href="#7-1-RDB-Redis-DateBase" class="headerlink" title="7.1 RDB ( Redis DateBase )"></a>7.1 RDB ( Redis DateBase )</h2><p>在主从复制中rdb就是备用了，从机上面</p>
<blockquote>
<p>什么是RDB</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831194739533.png" alt="image-20210831194739533"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘.也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。<br>Redis会单独创建( fork ) 一个子进程来进行持久化.会先将数据写入到一个临时文件中。待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后- 次持久化后的数据可能丢失。</p>
<p>==rdb保存的文件是dump.rdb==</p>
<p>生产环境，我们会将这个文件进行备份</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save 的规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令，也会触发我们的rdb规则</li>
<li>退出redis，也会产生rdb文件</li>
</ol>
<p>备份就会自动生成一个dump.rdb文件</p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<p>只需要将rdb文件放到Redis启动目录就可以了，redis启动时会自动检查dump.rdb回符其中的数据</p>
<p>==几乎自己的默认配置就足够用了==</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性不高</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>，需要一定的时间间隔，如果redis意外宕机，最后一次修改的数据就没有了</li>
<li>fork进程的时候，会占用一定的内存空间</li>
</ol>
<h2 id="7-2-AOF-Append-Only-File"><a href="#7-2-AOF-Append-Only-File" class="headerlink" title="7.2 AOF ( Append Only File )"></a>7.2 AOF ( Append Only File )</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部进行一遍</p>
<p>以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) ,只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之. redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>==aof保存的文件是appendonly.aof==</p>
<blockquote>
<p>流程</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210831200916268.png" alt="image-20210831200916268"></p>
<ol>
<li>写入缓存：每次执行命令后，进行append操作写入AOF缓存</li>
<li>同步磁盘：AOF 缓冲区根据对应的策略向硬盘进行同步操作。</li>
<li>AOF重写：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li>重启加载： 当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<h3 id="7-2-1-写入缓存"><a href="#7-2-1-写入缓存" class="headerlink" title="7.2.1 写入缓存"></a>7.2.1 写入缓存</h3><p>每次执行命令都是通过call()，call的时候会把命令写入aof缓存，也就是server.aof_buf</p>
<p>调用链： call() -&gt; propogate() -&gt; feedAppendOnlyFile</p>
<pre><code class="c">void call(client *c, int flags) &#123;
    ...
    propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);
&#125;

void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
               int flags)
&#123;
    ...
    if (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)
        feedAppendOnlyFile(cmd,dbid,argv,argc);
    ...
&#125;
</code></pre>
<blockquote>
<p>feedAppendOnlyFile()</p>
</blockquote>
<pre><code class="c">void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) &#123;
    // 把命令解析编码，比较复杂，
    buf = catAppendOnlyGenericCommand(buf,argc,argv);
    // 然后存入server.aof_buf
    server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
   // 如果子进程正在重写AOF，就把buf写入server.aof_rewrite_buf_blocks链表
    if (server.child_type == CHILD_TYPE_AOF)
        aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
&#125;
</code></pre>
<ol>
<li><p>解析命令</p>
<pre><code class="c\">buf = catAppendOnlyGenericCommand(buf,argc,argv);
</code></pre>
<p>该函数主要工作就是解析命令，把传入的cmd和argv，argc解析成<code>&quot;*3\r\n3\r\nSET\r\n5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;</code>的样子，存储在buff里</p>
</li>
<li><p>写入缓存</p>
<p><code>server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</code></p>
<p>把解析好的命令写入缓存，同步给磁盘</p>
</li>
<li><p>如果子进程正在重写AOF文件，则把解析好的命令写入server.aof_rewrite_buf_blocks链表</p>
<p>server.child_type表示子进程正在进行什么工作，在AOF重写(rewrite)过程中会创建子进程执行重写工作，这个在下面介绍AOF重写的时候会解释这里</p>
</li>
</ol>
<h3 id="7-2-2-同步磁盘"><a href="#7-2-2-同步磁盘" class="headerlink" title="7.2.2 同步磁盘"></a>7.2.2 同步磁盘</h3><p>同步磁盘的操作在函数<strong>flushAppendOnlyFike()</strong></p>
<p><code>flushAppendOnlyFile</code>函数的行为由redis.conf配置中的appendfsync选项的值来决定。该选项有三个可选值，分别是<code>always</code>,<code>everysec</code>和<code>no</code>:</p>
<ul>
<li><strong>always:</strong> Redis在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且同不AOF文件，所以always的效率是最差的一个，但从安全性来说也是最安全的，当发生故障停机时，AOF持久化也只会丢失一个事件循环中所产生的命令数据。</li>
<li><strong>everysec:</strong> Redis 在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF</li>
</ul>
<p>如果AOF文件有错位，Redis则无法启动，此时需要修复这个AOF文件，Redis提供的修复工具:<code>redis-check-aof --fix</code></p>
<blockquote>
<p>重写规则</p>
</blockquote>
<p>aof默认就是文件的无限追加，文件会越来越大</p>
<pre><code class="bash">auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb
</code></pre>
<p>如果AOF文件大于64M，太大了，fork一个新的进程会对我们的文件进行重写</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li>每一次修改都同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步。效率最高</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</li>
<li>AOF运行效率也要比RDB慢，所以Redis默认的配置就是RDB</li>
</ol>
<h2 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h2><ol>
<li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li>
<li>只做缓存.如果你只希望你的数据在服务器运行的时候存在.你也可以不使用任何持久化</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下。当redis重启的时候会优先载入A0F文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且不会有AOF可能潜在的Bug ,留着作为一个万一的手段。</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1这条规则。</li>
<li>如果Enable AOF . 好处是在最恶劣情况下也只会丢失不超过两秒数据.启动脚本较简单只load自己的AOF文件就可以了,代价一是带来了持续的IO ，.二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率,AOF重写的基础大小默认值64M太了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF , 仅靠Master-Slave Repllcation实现高可用性也可以,能省掉一大笔I0 ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。</li>
</ul>
</li>
</ol>
<h1 id="八、Redis发布订阅"><a href="#八、Redis发布订阅" class="headerlink" title="八、Redis发布订阅"></a>八、Redis发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种==消息通信模式==︰发送者(pub)发送消息，订阅者(sub)接收消息。Redis客户端可以订阅任意数量的频道。<br>订阅/发布消息图:</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901145241295.png" alt="image-20210901145241295"></p>
<pre><code class="bash">PUBLISH [name] [message] # 发布消息到频道[name]SUBSCRIBE [name ...] # 订阅频道nameUNSUBSCRIBE [name] # 取消订阅频道name
</code></pre>
<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的，通过分析Redis源码里的pubsut.c文件，了解发布和订阅机制的底层实现，籍此加深对Redis的理解。Redis 通过UBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。<br>通过SUBSCRIBE命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个channel，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。通过PUBLlSH命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。<br>Pub/Sub从字面上理解就是发布( Publish )与订阅 (Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p>微信：</p>
<p>通过SUBSCRIBE命令订阅某频道后, |redis-server里维护了一个字典,字典的键就是一一个个 频道! , 而字典的值则是一个链表链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。</p>
<p>Pub/Sub从字面.上理解就是发布( Publish )与订阅( Subscribe) , 在Redis中,你可以设定对某一-个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。</p>
<blockquote>
<p>用途</p>
</blockquote>
<ul>
<li>实时消息系统，比如普通的即时聊天,群聊等功能。</li>
<li>实时聊天 ( 频道当作聊天室，将信息回显给所有人即可 )</li>
<li>订阅，关注系统都是可以的</li>
</ul>
<h1 id="下述部分在《Redis高级》中详解"><a href="#下述部分在《Redis高级》中详解" class="headerlink" title="= = = = 下述部分在《Redis高级》中详解 = = = = ="></a>= = = = 下述部分在《Redis高级》中详解 = = = = =</h1><h1 id="九、Redis主从复制"><a href="#九、Redis主从复制" class="headerlink" title="九、Redis主从复制"></a>九、Redis主从复制</h1><h2 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h2><p>主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(master/leader) ,后者称为从节点(slave/follower) ;数据的复制是单向的,只能由主节点到从节点。Master以写为主, Slave以读为主。<br>默认情况下,每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点) ,但一个从节点只能有一个主节点。</p>
<blockquote>
<p><strong>主从复制的主要作用</strong></p>
</blockquote>
<ol>
<li>数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li>
<li>故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复;实际上是- -种服务的冗余。</li>
<li>负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点) , 分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高Redis服务器的并发量。</li>
<li>高可用(高可用—&gt;集群)基石:除了上述作用以外,主从复制还是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础。</li>
</ol>
<blockquote>
<p>一般来说,要将Redis运用于工程项目中,只使用一台Redis是万万不能的,原因如下</p>
</blockquote>
<ol>
<li>从结构上,单个Redis服务器会发生单点故障,并且一台服务器需要处理所有的请求负载,压力较大;</li>
<li>从容量上,单个Redis服务器内存容量有限,就算一台Redis服务 器内存容量为256G ,也不能将所有内存用作Redis存储内存,一般来说,==单台Redis最大使用内存不应该超过20G==。</li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，也就是多读少写，对于这种场景，通常使用这种架构：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901162443186.png" alt="image-20210901162443186"></p>
<p>主从复制，读写分离。80%的情况都是进行读操作，减缓服务器的压力，架构中经常使用，最低配置：一主二从</p>
<p>只要在公司中，主从复制时必须要使用的，在真实的项目中不可能单机使用Redis</p>
<h2 id="9-2-环境配置"><a href="#9-2-环境配置" class="headerlink" title="9.2 环境配置"></a>9.2 环境配置</h2><p>配置主机</p>
<pre><code class="bash">127.0.0.1:6379&gt; info replication # 查看当前库的信息# Replicationrole:master # 角色 masterconnected_slaves:0 # 没有从机master_failover_state:no-failovermaster_replid:2e0dbfc18702474129a88e972702b9ef903eafddmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0
</code></pre>
<p>修改从机：</p>
<ol>
<li>端口</li>
<li>pid名字</li>
<li>log文件名字</li>
<li>dump.db的名字</li>
</ol>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901165123038.png" alt="image-20210901165123038"></p>
<h2 id="9-3-一主二从"><a href="#9-3-一主二从" class="headerlink" title="9.3 一主二从"></a>9.3 一主二从</h2><p>==默认情况下，每台Redis服务器都是主节点== 所以需要修改从机配置</p>
<p>一主(79) 二从(80、81)</p>
<p>从机中配置：</p>
<pre><code class="bash">SLAVEOF [host] [port] # 从机的指定的主机的host和port#信息127.0.0.1:6380&gt; INFO replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:7master_sync_in_progress:0slave_repl_offset:14slave_priority:100slave_read_only:1replica_announced:1connected_slaves:0master_failover_state:no-failovermaster_replid:13242a5fc3d3f219f26d6913b64fba0fe25d5572master_replid2:0000000000000000000000000000000000000000master_repl_offset:14second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:14
</code></pre>
<p>真实的从主配置应该在配置文件中配置，这样的话是永久的</p>
<blockquote>
<p>细节</p>
</blockquote>
<ul>
<li>主机可以写，从机不能写，只能读</li>
<li>如果主机断开连接，此时从机依然旧链接到主机(没有配置哨兵的情况下)，但是没有写操作，这个时候如果主机回来了，从机依旧可以读新写入的信息。</li>
<li>如果是使用命令行来配置的主从，此时如果重启了从机，从机就会变成主机。再恢复为从机时，数据就可以立马从主机中获取值</li>
</ul>
<blockquote>
<p>复制原理</p>
</blockquote>
<ol>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave， 并完成次完全同步。==</li>
</ol>
<ul>
<li>全量复制:而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制: Master继续将新的所有收集到的修改命令依次传给slave，完成同步</li>
</ul>
<p>但是只要是重新连接master ,一次完全同步 (全量复制)将被自动执行。数据一定可以在从机中看到</p>
<blockquote>
<p>层层链路 (了解)</p>
</blockquote>
<p>上一个master 连接下一个SLAVER</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901171619088.png" alt="image-20210901171619088"></p>
<p>此时也可以完成主从复制</p>
<p>如果丢失的了主节点，可以使用<code>SLAVEOF no one</code>让自己变成主机，其他的节点就可以<strong>手动</strong>连接到最新的主节点</p>
<h2 id="9-4-哨兵模式"><a href="#9-4-哨兵模式" class="headerlink" title="9.4 哨兵模式"></a><strong>9.4 哨兵模式</strong></h2><p><code>redis-sentinel</code></p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是:当主服务器宕机后，需要手动把一-台从服务器切换为主服务器,这就需要人工干预,费事费力,还会造成一段时间内服务不可用。这不是一种推荐的方式,更多时候,我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵)架构来解决这个问题。</p>
<p>能够后台监控主机是否故障,如果故障了根据投票数==自动将从库转换为主库。==</p>
<p>哨兵模式是一种特殊的模式,首先Redis提供了哨兵的命令,哨兵是一个独立的进程,作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例</strong>。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901173757791.png" alt="image-20210901173757791"></p>
<p>然而一个哨兵进程对Redis服务器进行监控,可能会出现问题,为此,我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控,这样就形成了多哨兵模式。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901185816883.png" alt="image-20210901185816883"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。</p>
<p>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行ailover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<p><font size="5em"><strong>如果主机宕机后，新的主机选举出来后，之前的主机恢复也只能作为新主机的从机</strong></font></p>
<blockquote>
<p>哨兵配置文件</p>
</blockquote>
<pre><code class="bash"># sentinel monitor 被监控的名称 host port 1 
# 数字1表示主机挂了，slave投票看让谁接替成为主机，票数最多的就会成为主机
sentinel monitor myredis 127.0.0.1 6379 1
</code></pre>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点他都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动更加健壮</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>Redis不容易在线扩容，集群容量一旦达到上限，在线扩容就十分的麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<blockquote>
<p>哨兵模式的全部配置</p>
</blockquote>
<pre><code class="bash"># Example sentinel.conf

# 哨兵[sentine]实例运行的端口默认26379
port 26379

#哨兵sentinel的工作目录
dir /tmp

# 哨兵sentinel监控的redis主节点的ip port
# master-name 可以自己命名的主节点名字只能由字A-z、数字0-9、&quot;.-_&quot;组成。
# quorum 配置多少个sentinel哨兵统一认为master主节点失联，那么这时客观上认为主节点失联了
# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;
sentine] monitor mymaster 127.0.0.1 6379 2


#当在Redis实例中开启了requirepass foobared 授权密码这样所有连接Redis实例的客户端都要提供密码
#设置哨兵sentinel连接主从的密码注意必须为主从设置一样的验证密码
# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
sentine1 auth-pass mymaster MySUPER--secret-0123passwOrd


#指定多少毫秒之后主节点没有应答哨兵sentinel此时哨兵主观上认为主节点下线   默认30秒
# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;
sentinel down-after-mi liseconds mymaster 30000


#这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，
##这个数字越小，完成failover所需的时间就越长，
##但是如果这个数字越大，就意味着越多的slave因为replication而不可用。
##可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。
# sentine1 paralle 7-syncs &lt;master-name&gt; &lt;nums 1 aves &gt;
sentine1 paralle 1-syncs mymaster 1

#故障转移的超时时间failover-timeout 可以用在以下这些方面:
#1.同一个sentinel对同一 个master两次failover之间的问隔时间。
#2.当一个slave从一 个错误的master那里同步數据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所而要的时间。
#4.当进行failover时，配置所有s1aves指向新的master所需的最大时间。不过，即使过了这个超时，slaves 依然会被正确配置为指向master,但是就不按parallel-syncs所配置的规则来了
#默认三分钟
# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;
sentine1 failover-timeout mymaster 180000
</code></pre>
<pre><code class="bash"># SCRIPTS EXECUTION

#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚木的运行结果有以下规则: 
#1.若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#2.若脚本执行后返回2.或者比2更高的一个返回值，脚本将不会重复执行。
#3.如果脚木在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#4.一个脚木的最大执行时间为60s，如果超过这个时间，脚本将会被- 个SIGKILL信号终止，之后重新执行。

#通知型脚本:当sentinel有任何警告级别的事件发生时( 比如说redis实例的主观失效和客观失效等等)，将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚木路径，那么必须保证这个脚木存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。

#通知脚本
#邮件的Shell编程
# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;
sentinel notification-script mymafter /var/redis/notify.sh 

#客户端重新配置主节点参数脚本
#当一个master由于failover而发生改变时，这个脚木将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
#以下多数将会在调用脚本时传给脚本:
# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;
#目前&lt;state&gt;总是&quot;failover&quot;,
# &lt;role&gt; 是&quot;leader&quot;或者“observer&quot;中的一个。
#参数from-ip, from-port, to-ip, to-port是用来和旧的master和新的master (即H的sTave)通信的
#这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh #一般都是运维来控制
</code></pre>
<h1 id="十、Redis缓存穿透和雪崩-重要"><a href="#十、Redis缓存穿透和雪崩-重要" class="headerlink" title="十、Redis缓存穿透和雪崩(重要)"></a><strong>十、Redis缓存穿透和雪崩</strong>(重要)</h1><p>Redis缓存的使用，极大的提升了应用程序的性能和效率,特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题,从严格意义。上讲,这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。<br>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<h2 id="10-1-缓存穿透"><a href="#10-1-缓存穿透" class="headerlink" title="10.1 缓存穿透"></a>10.1 缓存穿透</h2><blockquote>
<p>概念</p>
</blockquote>
<p>用户想要查询一个数据,发现redis内存数据库没有,也就是缓存没有命中,于是向持久层数据库查询。发<br>现也没有,于是本次查询失败。当用户很多的时候,缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力,这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>方法一：使用<strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构,对所有可能查询的参数以Hash形式存储,在控制层先进行校验,不符合则丢弃,从而避免了对底层存储系统的查询压力;</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901215146437.png" alt="image-20210901215146437"></p>
<p>方法二：<strong>缓存空对象</strong></p>
<p>当存储层不命中后,即使返回的空对象也将其缓存起来,同时会设置一个过期时间 ,之后再访问这个数据将会从缓存中获取，保护了后端数据源;</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901222252770.png" alt="image-20210901222252770"></p>
<p>但是这种方法会存在两个问题:<br>1、如果空值能够被缓存起来,这就意味着缓存需要更多的空间存储更多的键,因为这当中可能会有很多的空值的键;<br>2、即使对空值设置了过期时间,还是会存在缓存层和存储层的数据会有一-段时间窗口的不一-致 ,这对于需要保持一致性的业务会有影响。</p>
<h2 id="10-2-缓存击穿"><a href="#10-2-缓存击穿" class="headerlink" title="10.2 缓存击穿"></a>10.2 缓存击穿</h2><p>量太大，缓存过期</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别,缓存击穿,是指一个key非常热点;在不停的扛着大并发,大并发集中对这一个点进行访问,当这个key在失效的瞬间,持续的大并发就穿破缓存，直接请求数据库,就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间,有大量的请求并发访问这类数据一般是热点数据,由于缓存过期 ,会同时访问数据库来查询最新数据，并且回写缓存,会导使数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此分布式锁的考验很大</p>
<h2 id="10-3-缓存雪崩"><a href="#10-3-缓存雪崩" class="headerlink" title="10.3 缓存雪崩"></a>10.3 缓存雪崩</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效，Redis宕机</p>
<p>产生雪崩的原因之一 ,比如在写本文的时候，马.上就要到双十二零点,很快就会迎来一波抢购 ,这波商品时间比较集中的放入了缓存,假设缓存一个小时。那么到了凌晨一点钟的时候 ,这批商品的缓存就都过期了。而对这批商品的访问查询,都落到了数据库上,对于数据库而言,就会产生周期性的压力波峰。于是所有的请求都会达到存储层,存储层的调用量会暴增,造成存储层也会挂掉的情况。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210901223354610.png" alt="image-20210901223354610"></p>
<p>其实集中过期,倒不是非常致命,比较致命的缓存雪崩,是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩,一定是在某个时间段集中创建缓存,这个时候,数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的,很有可能瞬间就把数据库压垮。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>Redis的高可用</strong></p>
<p>这个思想的含义是,既然redis有可能挂掉,那我多增设几台redis ,这样一台挂掉之后其他的还可以继续工作,其实就是搭建的集群。</p>
<p>如 <em>双十一：停掉一些服务(保证主要的服务可用)</em></p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是,在缓存失效后,通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存,其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前,我先把可能的数据先预先访问-遍,这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key ,设置不同的过期时间,让缓存失效的时间点尽量均匀。</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Hexo
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>