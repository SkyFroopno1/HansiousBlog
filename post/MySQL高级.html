

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="零、前言@Author：韩霄杰(Hansious | SkyFroop) @Date: 20220209 @Update: 20220323 | 20220401 @Description: 本篇专注于MySQL DBMS的分析。若需要强化SQL参考《SQL》笔记。 [toc] 一、MySQL架构1.1 MySQL逻辑架构 1.连接层 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL高级">
<meta property="og:url" content="https://tridiamond.tech/post/MySQL%E9%AB%98%E7%BA%A7.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="零、前言@Author：韩霄杰(Hansious | SkyFroop) @Date: 20220209 @Update: 20220323 | 20220401 @Description: 本篇专注于MySQL DBMS的分析。若需要强化SQL参考《SQL》笔记。 [toc] 一、MySQL架构1.1 MySQL逻辑架构 1.连接层 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102123039770.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102131452342.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102131619820.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102215655473.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102221537029.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102223400062.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103141528903.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103142049370.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103142414802.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103142535963.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103143007337.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220103143455879.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220105161058285.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220105165523730.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220105165715532.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220105165958861.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220106125532068.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107122949240.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107125109912.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107125144884.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107151121735.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107151456717.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107151530203.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107152514152.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107152807131.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107153001546.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107153313111.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107154644751.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107154809445.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107155948779.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107162418663.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107163034508.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107163049327.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107212921332.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107213257876.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107215916362.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220107223918622.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220101131308574.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220101131534062.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327102850878.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327103136736.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327103522717.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327103903244.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327105002757.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220328203808540.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329173242591.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329173326184.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329173341294.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329173352093.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329185544139.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329190949543.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329191140863.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329191428818.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329191450289.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329194723833.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220329195045145.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327104734292.png">
<meta property="og:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220327104616851.png">
<meta property="article:published_time" content="2022-04-25T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T13:48:41.085Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="DBA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20220102123039770.png">
  
  
  
  <title>MySQL高级 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tridiamond.tech","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL高级"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-26 00:00" pubdate>
          April 26, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          28k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          237 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL高级</h1>
            
            <div class="markdown-body">
              
              <h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>@Author：韩霄杰(Hansious | SkyFroop)</p>
<p>@Date: 20220209</p>
<p>@Update: 20220323 | 20220401</p>
<p>@Description: 本篇专注于MySQL DBMS的分析。若需要强化SQL参考《SQL》笔记。</p>
<p>[toc]</p>
<h1 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h1><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102123039770.png" srcset="/img/loading.gif" lazyload alt="image-20220102123039770"></p>
<p>1.连接层</p>
<p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcpip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>⒉服务层</p>
<p>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3.引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p>
<p>4.存储层</p>
<h2 id="1-2-存储引擎"><a href="#1-2-存储引擎" class="headerlink" title="1.2  存储引擎"></a>1.2  存储引擎</h2><blockquote>
<p>查看本机的存储引擎</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102131452342.png" srcset="/img/loading.gif" lazyload alt="image-20220102131452342"></p>
<blockquote>
<p>MyISAM和InnoDB的区别</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102131619820.png" srcset="/img/loading.gif" lazyload alt="image-20220102131619820"></p>
<h1 id="二、索引优化"><a href="#二、索引优化" class="headerlink" title="二、索引优化"></a>二、索引优化</h1><h2 id="2-1-SQL解析"><a href="#2-1-SQL解析" class="headerlink" title="2.1 SQL解析"></a>2.1 SQL解析</h2><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102215655473.png" srcset="/img/loading.gif" lazyload alt="image-20220102215655473"></p>
<h2 id="2-2-索引"><a href="#2-2-索引" class="headerlink" title="2.2 索引"></a>2.2 索引</h2><p>MySQL官方对索引的定义为:索引(Index）是帮助MySQL高效获取数据的数据结构。数据本身之外，数据库还维护着一个满足特定查找算法的数据结构(B树)，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p>
<h3 id="2-2-1-索引数据结构概述"><a href="#2-2-1-索引数据结构概述" class="headerlink" title="2.2.1 索引数据结构概述"></a>2.2.1 索引数据结构概述</h3><p>==可以得到索引的本质:索引是数据结构。==</p>
<p>可以简单的理解为“排好序的快速查找数据结构” —&gt; 索引的功能：排序，快速查找</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102221537029.png" srcset="/img/loading.gif" lazyload alt="image-20220102221537029"></p>
<p>左边是数据表，-共有两列七条记录，最左边的是数据记录的物理地址</p>
<p>为了加快Col2的查找，可以维护-一个右边所示的二叉查找树，每个节点分别包含索引键值和–个指向对应数据记录物理地止的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>
<blockquote>
<p>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不-一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引等</p>
</blockquote>
<h3 id="2-2-2-优缺点"><a href="#2-2-2-优缺点" class="headerlink" title="2.2.2 优缺点"></a>2.2.2 优缺点</h3><p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本；</li>
<li>通过索引对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。<br>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
</ul>
<p>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，</p>
<h3 id="2-2-3-索引分类和索引结构"><a href="#2-2-3-索引分类和索引结构" class="headerlink" title="2.2.3 索引分类和索引结构"></a>2.2.3 索引分类和索引结构</h3><ul>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>聚集索引(聚簇索引；主键索引)：数据行的<strong>物理顺序与列值（一般是主键的那一列）的逻辑顺序相同</strong>，一个表中只能拥有一个聚集索引。<ul>
<li>一个没加主键的表，它的数据<strong>无序</strong>的放置在磁盘存储器上</li>
<li>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了<strong>树状结构</strong>，也就是<strong>平衡树结构</strong>，换句话说，就是整个表就变成了一个索引，也就是所谓的<strong>聚集索引</strong>。</li>
</ul>
</li>
<li>非聚集索引(常规索引)：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</li>
</ul>
<blockquote>
<p>聚集索引和非聚集索引的主要区别</p>
</blockquote>
<ul>
<li>通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。</li>
<li>聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。</li>
</ul>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220102223400062.png" srcset="/img/loading.gif" lazyload alt="image-20220102223400062"></p>
<p>索引结构：</p>
<ul>
<li>Btree索引</li>
<li>Hash索引</li>
<li>Full-test全文索引</li>
<li>R-Tree索引</li>
</ul>
<blockquote>
<p> 何时创建索引</p>
</blockquote>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>Where条件里用不到的字段不创建索引</li>
<li>单键/组合索引的选择问题，</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li>
<li>查询中统计或者分组的字段</li>
</ol>
<blockquote>
<p>何时不能创建索引</p>
</blockquote>
<ol>
<li>表记录太少(三百万以下)</li>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引</li>
<li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果</li>
</ol>
<p>​    假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率天约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。<br>​    索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，这个索引的效率就越高。</p>
<h2 id="2-3-性能分析"><a href="#2-3-性能分析" class="headerlink" title="2.3 性能分析"></a>2.3 性能分析</h2><p>MySQL常见瓶颈：</p>
<ul>
<li>CPU:CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO:磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈:top,free, iostat和vmstat来查看系统的性能状态</li>
</ul>
<h3 id="2-3-1-Explain"><a href="#2-3-1-Explain" class="headerlink" title="2.3.1 Explain"></a>2.3.1 Explain</h3><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析查询语句或是表结构的性能瓶颈</p>
<blockquote>
<p>能做什么</p>
</blockquote>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<blockquote>
<p>用法</p>
</blockquote>
<p>EXPLAIN + SQL语句</p>
<p>可以查出如下信息</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103141528903.png" srcset="/img/loading.gif" lazyload alt="image-20220103141528903"></p>
<p>各字段解释：</p>
<ul>
<li><p><strong>id</strong>：</p>
<p>​    id相同：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103142049370.png" srcset="/img/loading.gif" lazyload alt="image-20220103142049370"></p>
<ul>
<li><p>执行顺序由上至下</p>
<p>id不同：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103142414802.png" srcset="/img/loading.gif" lazyload alt="image-20220103142414802"></p>
</li>
<li><p>如果是子查询，那么id的序号会递增，id值越大，优先级越高，越先被执行</p>
<p>id有的相同有的不同</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103142535963.png" srcset="/img/loading.gif" lazyload alt="image-20220103142535963"></p>
</li>
<li><p>id如果相同，可以认为是一组，从上往下顺序执行;在所有组中，id值越大，优先级越高，越先执行</p>
<ul>
<li>DERIVED = 衍生，derived2就是id为2的那个衍生表</li>
</ul>
</li>
</ul>
</li>
<li><p>select_type</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103143007337.png" srcset="/img/loading.gif" lazyload alt="image-20220103143007337" style="zoom:50%;" />

<ul>
<li>SIMPLE：简单的select查询,查询中不包含子查询或者UNION</li>
<li>PRIMARY：查询中若包含任何复杂的子部分,最外层查询则被标记为</li>
<li>SUBQUERY：在SELECT或WHERE列表中包含了子查询</li>
<li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询,把结果放在临时表里。</li>
<li>UNION：若第二个SELECT出现在UNION之后,则被标记为UNION，若UNION包含在FROM子句的子查询中,外层SELECT将被标记为:DERIVED</li>
<li>UNION RESULT：从UNION表获取结果的SELECT</li>
</ul>
</li>
<li><p>table：数据来自于哪张表</p>
</li>
<li><p><strong>type</strong>：显示查询使用了哪种类型</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220103143455879.png" srcset="/img/loading.gif" lazyload alt="image-20220103143455879"></p>
<ul>
<li>从最好到最差：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null&gt; unique_subquert &gt; index_subquert &gt; range &gt; index &gt; ALL</li>
<li>==常用：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL，一般来说，得保证查询至少达到range级别，最好ref级别==</li>
<li>system：表只有一行记录（等于系统表)，这是const类型的特列，平时不会出现，这个也可以忽略不计</li>
<li>constant：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很悦如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描,返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>
<li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的)</li>
<li>ALL：Full Table Scan，将遍历全表以找到匹配的行</li>
</ul>
</li>
<li><p>possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，==但不一定被查询实际使用==，即可能使用到的索引</p>
</li>
<li><p>key：实际使用的索引。如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p>
</li>
<li><p>key_len：表示索引中使用的字节数，可炬过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好；key_len显示的值为索引字段的最大可能长度，==并非实际使用长度==，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
</li>
<li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
</li>
<li><p>rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
</li>
<li><p><strong>Extra</strong>：包含不适合在其他列中显示但十分重要的额外信息</p>
<ul>
<li><p><strong>Using filesort</strong>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为”文件排序”</p>
</li>
<li><p><strong>Using temporary</strong>：使了用临时表保存中间结果,My5QL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by</p>
</li>
<li><p><strong>Using index</strong>：表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p>
<ul>
<li><p>覆盖索引(索引覆盖)：</p>
<p>理解方式一:就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。</p>
<p>理解方式二:索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了(或覆盖了)满足查询结果的数据就叫做覆盖索引。</p>
</li>
</ul>
</li>
<li><p>Using Where：表明使用了Where过滤</p>
</li>
<li><p>Using Join buffer：使用了连接缓存</p>
</li>
<li><p>impossible where：Where子句的值总是false，不能用来获取任何元组</p>
</li>
<li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作,不必等到执行阶段再进行计算,查询执行计划生成的阶段即完成优化。</p>
</li>
<li><p>distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220105161058285.png" srcset="/img/loading.gif" lazyload alt="image-20220105161058285"></p>
<h2 id="2-4-单表案例"><a href="#2-4-单表案例" class="headerlink" title="2.4 单表案例"></a>2.4 单表案例</h2><p><strong>案例查询语句</strong>：SELECT id ,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;</p>
<blockquote>
<p>无索引，EXPLAIN：</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220105165523730.png" srcset="/img/loading.gif" lazyload alt="image-20220105165523730"></p>
<p>type为ALL，全表搜索，Extra中出现Using filesort运行时排序。效率极差</p>
<blockquote>
<p>建立索引：INDEX(category_id , comments , views)</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220105165715532.png" srcset="/img/loading.gif" lazyload alt="image-20220105165715532"></p>
<p>type从ALL优化到了range，但这样设置索引后仍然在Extra中发现了Using filesort</p>
<p>如果把comments &gt; 1改为 comments = 1，则Using filesort消失</p>
<p>==这是因为“大于“属于range，他以及其后的索引则会失效==</p>
<blockquote>
<p>建立索引：INDEX(category_id , views)</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220105165958861.png" srcset="/img/loading.gif" lazyload alt="image-20220105165958861"></p>
<p>type从range优化为了ref，Using filesort也消失</p>
<h2 id="2-5-两表案例"><a href="#2-5-两表案例" class="headerlink" title="2.5 两表案例"></a>2.5 两表案例</h2><p>结论：</p>
<ul>
<li>左连接时，为右表添加索引。这是由左连接特性决定的。LEFT JOIN条件用于确定如何从右表搜索行,左边一定都有，所以右边是我们的关键点，一定需要建立索引</li>
<li>右连接时，与左连接情况相反</li>
</ul>
<h2 id="2-6-三表案例"><a href="#2-6-三表案例" class="headerlink" title="2.6 三表案例"></a>2.6 三表案例</h2><p>类比两表案例情况</p>
<ul>
<li>尽可能的减少Join 语句中NestedLoop的循环总次数；“永远用小结果集驱动大的结果集”。</li>
<li>优先优化NestedLoop的内层循环</li>
<li>保证Join语句中被驱动表上Join条件字段已经被索引</li>
<li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置</li>
</ul>
<h2 id="2-7-索引失效"><a href="#2-7-索引失效" class="headerlink" title="2.7 索引失效"></a>2.7 索引失效</h2><ol>
<li><p>尽可能的使用全值匹配</p>
</li>
<li><p>最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且<strong>不跳过索引中的列.</strong> (左边大哥不能死，中间兄弟不能断)</p>
</li>
<li><p>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</p>
</li>
<li><p>存储引擎不能使用索引中范围条件右边的列</p>
</li>
<li><p>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少SELECT *</p>
</li>
<li><p>MySQL在使用不等于(!= 或者&lt;&gt;)时无法使用索引，会导致全表扫描</p>
</li>
<li><p>is null，is not null 也无法使用索引</p>
</li>
<li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220106125532068.png" srcset="/img/loading.gif" lazyload alt="image-20220106125532068"></p>
<ul>
<li>Like最好是在右边加 百分号(%)</li>
<li>解决like %字符串% 索引失效的方法：覆盖索引</li>
</ul>
</li>
<li><p>字符串不加单引号索引失效：根本原因是，MySQL底层会隐式的进行类型转换，见第3点</p>
</li>
<li><p> 少用or，用它来连接会索引失效</p>
</li>
</ol>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107122949240.png" srcset="/img/loading.gif" lazyload alt="image-20220107122949240"></p>
<ul>
<li><p>排序字段已经是一个常量时，order by的索引乱序可以不用using filesort</p>
</li>
<li><p>定值、范围还是排序，一般order by是给个范围group by基本上都需要进行排序，会有临时表产生</p>
</li>
</ul>
<h2 id="2-8-一般性建议"><a href="#2-8-一般性建议" class="headerlink" title="2.8 一般性建议"></a>2.8 一般性建议</h2><ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引、</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠左越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<h1 id="三、查询截取优化"><a href="#三、查询截取优化" class="headerlink" title="三、查询截取优化"></a>三、查询截取优化</h1><h2 id="3-1-查询优化"><a href="#3-1-查询优化" class="headerlink" title="3.1 查询优化"></a>3.1 查询优化</h2><h3 id="3-1-1-永远小表驱动大表"><a href="#3-1-1-永远小表驱动大表" class="headerlink" title="3.1.1 永远小表驱动大表"></a>3.1.1 永远小表驱动大表</h3><p>即小的数据集驱动大的数据集</p>
<p>原理：</p>
<ul>
<li>EXISTS：SELECT … FROM table WHERE EXISTS (subquery)<ul>
<li>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果(TRUE或FALSE)来决定主查询的数据结果是否得以保留。</li>
</ul>
</li>
<li>提示：<ol>
<li>EXISTS(subquery)只返回TRUE或FALSE，因此子查询中的SELECT *也可以是SELECT 1或其他(SELECT ‘X’)，官方说法是实际执行时会忽略SELECT清单，因此没有区别</li>
<li>EXISTS 子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际校验以确定是否有效率问题</li>
<li>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来题代，何种最优需要具体问题具体分析。</li>
</ol>
</li>
</ul>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107125109912.png" srcset="/img/loading.gif" lazyload alt="image-20220107125109912"></p>
<p>当B表的数据集必须小于A表的数据集时，用in优于exists</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107125144884.png" srcset="/img/loading.gif" lazyload alt="image-20220107125144884"></p>
<p>当A表的数据集必须小于B表的数据集时，用exists优于in</p>
<p><em>A表和B表的id都应当建立索引</em></p>
<h3 id="3-1-2-Order-By优化"><a href="#3-1-2-Order-By优化" class="headerlink" title="3.1.2 Order By优化"></a>3.1.2 Order By优化</h3><blockquote>
<p>1、 ORDER BY 子句，尽量使用Index方式排序，避免使用FileSort方式排序</p>
</blockquote>
<ul>
<li>默认是升序排序。如果出现ASC则FileSort<ul>
<li>均为DESC则不会导致索引失效</li>
</ul>
</li>
<li>Order By覆盖索引，且最左法则，则Index。<ul>
<li>ORDER BY语句使用索引最左前列</li>
<li>使用where子句与Order BY子句条件列组合满足索引最左前列</li>
</ul>
</li>
</ul>
<p>MySQL支持二种方式的排序,FileSort和lIndex，Index效率高.它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>
<blockquote>
<p>2、 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
</blockquote>
<blockquote>
<p>3、 如果不在索引列上，FileSort有两种算法：MySQL就要启动双路排序和单路排序</p>
</blockquote>
<ul>
<li>双路排序：MySQL 4.1 之前使用的是双路排序，字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
</ul>
<p>取一批数据，要对磁盘进行了两次扫描，众所周知，TO是很耗时的，所以在mysq/4.1之后，出现了第二种改进的算法，就是单路排序。</p>
<ul>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机I0变成了顺序I0,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li>
</ul>
<p>单路总体而言好于双路，但是使用单路会出现一个问题：</p>
<p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小,再排…..从而多次IO。</p>
<p>本来想省一次I/O操作,反而导致了大量的I/O操作，反而得不偿失。</p>
<blockquote>
<p>优化策略</p>
</blockquote>
<ol>
<li>增大sort_buffer_size参数的设置<ul>
<li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的</li>
</ul>
</li>
<li>增大max_length_for_sort_data参数的设置<ul>
<li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率.</li>
</ul>
</li>
<li>Order by时select*是一个大忌只Query需要的字段，这点非常重要。在这里的影响是:<ul>
<li>当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXTIBLOB类型时，会用改进后的算法一一单路排序，否则用老算法——多路排序。</li>
<li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些,所以要提高sort buffer size。</li>
</ul>
</li>
</ol>
<h3 id="3-1-3-Group-By优化"><a href="#3-1-3-Group-By优化" class="headerlink" title="3.1.3 Group By优化"></a>3.1.3 Group By优化</h3><p>趋同于Order By的优化</p>
<ul>
<li>group by实质是先排序后进行分组,遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了。</li>
</ul>
<h2 id="3-2-慢查询日志"><a href="#3-2-慢查询日志" class="headerlink" title="3.2 慢查询日志"></a>3.2 慢查询日志</h2><blockquote>
<p>是什么</p>
</blockquote>
<ul>
<li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</li>
<li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</li>
</ul>
<p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p>
<blockquote>
<p>使用方式</p>
</blockquote>
<p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 默认<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>;<br># 开启,如果MySQL重启，则会自动关闭<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br># 永久生效需要修改配置文件：my.cnf<br># 查看阙值<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;long_query_time%&#x27;</span>;<br># 设置慢的阙值时间：<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time <span class="hljs-operator">=</span> s;<br><span class="hljs-comment">-- 修改后看不到值被修改</span><br><span class="hljs-comment">-- 需要重新连接或新开一个会话才能看到修改值。</span><br><span class="hljs-comment">-- SHOW VARIABLES LIKE &#x27;long_query_time%&quot;;</span><br><span class="hljs-comment">-- show global variables like &#x27;long_query_time&#x27;;</span><br><br></code></pre></td></tr></table></figure>

<p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log</p>
<p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。在mysql源码里是判断大于long_query_time，而非大于等于。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107151121735.png" srcset="/img/loading.gif" lazyload alt="image-20220107151121735"></p>
<blockquote>
<p>日志分析工具 mysqldumpslow</p>
</blockquote>
<p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107151456717.png" srcset="/img/loading.gif" lazyload alt="image-20220107151456717" style="zoom: 67%;" />

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107151530203.png" srcset="/img/loading.gif" lazyload alt="image-20220107151530203" style="zoom: 58%;" />



<h2 id="3-3-批量数据脚本案例"><a href="#3-3-批量数据脚本案例" class="headerlink" title="3.3 批量数据脚本案例"></a>3.3 批量数据脚本案例</h2><p>案例：查入1000w</p>
<blockquote>
<p>1、建库建表</p>
</blockquote>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107152514152.png" srcset="/img/loading.gif" lazyload alt="image-20220107152514152" style="zoom: 50%;" />

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107152807131.png" srcset="/img/loading.gif" lazyload alt="image-20220107152807131" style="zoom:50%;" />

<blockquote>
<p>2、设置参数log_bin_trust_function_creators</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107153001546.png" srcset="/img/loading.gif" lazyload alt="image-20220107153001546"></p>
<blockquote>
<p>3、创建函数，保证每条数据不同</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107153313111.png" srcset="/img/loading.gif" lazyload alt="image-20220107153313111"></p>
<blockquote>
<p> 4、创建存储过程</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107154644751.png" srcset="/img/loading.gif" lazyload alt="image-20220107154644751"></p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107154809445.png" srcset="/img/loading.gif" lazyload alt="image-20220107154809445"></p>
<blockquote>
<p>5、 调用存储过程</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107155948779.png" srcset="/img/loading.gif" lazyload alt="image-20220107155948779"></p>
<h2 id="3-4-Show-Profile"><a href="#3-4-Show-Profile" class="headerlink" title="3.4 Show Profile"></a>3.4 Show Profile</h2><p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sQL的调优的测量</p>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<p>分析步骤：</p>
<ol>
<li><p>是否支持，查看当前MySQL版本是否支持</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;profiling&#x27;</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>开启功能，默认是关闭的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> profiling<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>运行SQL</p>
</li>
<li><p>查看结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> profiles;<br></code></pre></td></tr></table></figure></li>
<li><p>诊断SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Show</span> Profile cpu,block io <span class="hljs-keyword">for</span> query (<span class="hljs-keyword">Show</span> profiles中问题<span class="hljs-keyword">SQL</span>数字号码，即Query_ID)<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107162418663.png" srcset="/img/loading.gif" lazyload alt="image-20220107162418663"></p>
</li>
</ol>
<blockquote>
<p>应该要注意的点</p>
</blockquote>
<ul>
<li>converting HEAP to MyISAM查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li>Creating tmp table创建临时表<ul>
<li>拷贝数据到临时表</li>
<li>用完再删除</li>
</ul>
</li>
<li>Copying to tmp table on disk把内存中临时表复制到磁盘，危险！！</li>
<li>locked</li>
</ul>
<h2 id="3-5-全局查询日志"><a href="#3-5-全局查询日志" class="headerlink" title="3.5 全局查询日志"></a>3.5 全局查询日志</h2><p>==只能用于测试环境，切不可用于线上环境==</p>
<p>启用方式：</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107163034508.png" srcset="/img/loading.gif" lazyload alt="image-20220107163034508" style="zoom:67%;" />

<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107163049327.png" srcset="/img/loading.gif" lazyload alt="image-20220107163049327"></p>
<h1 id="四、锁机制"><a href="#四、锁机制" class="headerlink" title="四、锁机制"></a>四、锁机制</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、V/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h2 id="4-0-SELECT-…-FOR-UPDATE"><a href="#4-0-SELECT-…-FOR-UPDATE" class="headerlink" title="4.0 SELECT … FOR UPDATE"></a>4.0 SELECT … FOR UPDATE</h2><p>FOR UPDATE 仅适用于InnoDB，且必须在事务区块(BEGIN/COMMIT)中才能生效。</p>
<p>使用select…for update会把数据给锁住，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<ul>
<li>例1: (明确指定主键，并且有此数据，row lock)</li>
</ul>
<p>SELECT * FROM products WHERE id=’3’ FOR UPDATE;</p>
<ul>
<li>例2: (明确指定主键，若查无此数据，无lock)</li>
</ul>
<p>SELECT * FROM products WHERE id=’-1’ FOR UPDATE;</p>
<ul>
<li>例2: (无主键，table lock)</li>
</ul>
<p>SELECT * FROM products WHERE name=’Hansious’ FOR UPDATE;</p>
<ul>
<li>例3: (主键不明确，table lock)</li>
</ul>
<p>SELECT * FROM products WHERE id&lt;&gt;’3’ FOR UPDATE;</p>
<ul>
<li>例4: (主键不明确，table lock)</li>
</ul>
<p>SELECT * FROM products WHERE id LIKE ‘3’ FOR UPDATE;</p>
<h2 id="4-1-锁的分类"><a href="#4-1-锁的分类" class="headerlink" title="4.1 锁的分类"></a>4.1 锁的分类</h2><p><em>更详细可参考[附录D](#附录D LBCC)</em></p>
<blockquote>
<p>从对数据操作的类型(读/写)分</p>
</blockquote>
<ul>
<li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会相互影响</li>
<li>写锁(排他锁)：当前写操作没有完成前，他会阻断其他写锁和读锁</li>
</ul>
<blockquote>
<p>从对数据操作的粒度分</p>
</blockquote>
<ul>
<li>表锁</li>
<li>行锁</li>
</ul>
<h2 id="4-2-表锁-偏读"><a href="#4-2-表锁-偏读" class="headerlink" title="4.2 表锁(偏读)"></a>4.2 表锁(偏读)</h2><p>特点：</p>
<ul>
<li>偏向MyISAM存储引擎，开销小，加锁快;</li>
<li>无死锁;</li>
<li>锁定粒度大，发生锁冲突的概率最高,并发度最低</li>
</ul>
<blockquote>
<p>加锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看锁<br><span class="hljs-keyword">Show</span> <span class="hljs-keyword">open</span> tables;<br># 加读锁<br>lock <span class="hljs-keyword">table</span> [表名] read;<br># 加写锁<br>lock <span class="hljs-keyword">table</span> [表名] write;<br># 释放锁<br>unlock tables;<br></code></pre></td></tr></table></figure>

<ul>
<li>施加读锁时<ul>
<li>自己可以读自己的锁定表，别人可以读自己的加锁表</li>
<li>自己和别人都 不可以修改加锁表，自己修改会报错，别人修改会堵塞</li>
<li>自己不可以读自己的非加锁表，别人可以读自己的非加锁表</li>
</ul>
</li>
<li>施加写锁时<ul>
<li>自己可以读自己的锁定表；别人<strong>不</strong>可以读自己的加锁表，会阻塞</li>
<li>自己可以修改加锁表；别人不可以修改加锁表</li>
<li>自己不可以读自己的非加锁表；别人可以读自己的非加锁表</li>
</ul>
</li>
</ul>
<ol>
<li>对MyISAM表的读操作〈加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li>
<li>对MyISAM表的写操作（加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li>
</ol>
<blockquote>
<p>锁分析</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> Status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;table%&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下:</p>
<ul>
<li>Table_locks_immediate:产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1 ;</li>
<li>Table_locks waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况;</li>
</ul>
<p>此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞</p>
<h2 id="4-3-行锁-偏写"><a href="#4-3-行锁-偏写" class="headerlink" title="4.3 行锁(偏写)"></a>4.3 行锁(偏写)</h2><p>特点：</p>
<ul>
<li>偏向InnoDB存储引擎，开销大，加锁慢;</li>
<li>会出现死锁;</li>
<li>锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
</ul>
<p>InnoDB与MyISAM的最大不同有两点:一是支持事务（TRANSACTION)﹔二是采用了行级锁</p>
<blockquote>
<p>误操作导致无索引行锁升级为表锁</p>
</blockquote>
<p>索引失效，如varchar必须加单引号等</p>
<blockquote>
<p>间隙锁的危害</p>
</blockquote>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙”，</p>
<p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107212921332.png" srcset="/img/loading.gif" lazyload alt="image-20220107212921332" style="zoom:80%;" />

<p>没有a = 2，产生间隙</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;2000&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>session1 commit之前，session2会被阻塞</p>
<ul>
<li>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，<strong>即使这个键值并不存在。</strong></li>
<li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</li>
</ul>
<blockquote>
<p>如何锁定一行</p>
</blockquote>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107213257876.png" srcset="/img/loading.gif" lazyload alt="image-20220107213257876"></p>
<blockquote>
<p>锁分析</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>lnnodb_row_lock_current_waits:当前正在等待锁定的数量;</li>
<li>Innodb_row_lock_time:从系统启动到现在锁定总时间长度;</li>
<li>Innodb_row_lock_time_avg:每次等待所花平均时间;</li>
<li>Innodb_row_lock_time_max:从系统启动到现在等待最常的一次所花的时间;</li>
<li>Innodb_row_lock_waits:系统启动后到现在总共等待的次数;</li>
</ul>
<p>对于这5个状态变量，比较重要的主要是:</p>
<ul>
<li>Innodb_row_lock_time_avg (等待平均时长)，</li>
<li>Innodb_row_lock_waits(等待总次数)</li>
<li>Innodb_row_lock_time(等待总时长)</li>
</ul>
<p>这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p>
<h2 id="4-4-页锁"><a href="#4-4-页锁" class="headerlink" title="4.4 页锁"></a>4.4 页锁</h2><p>特点：</p>
<ul>
<li>开销和加锁时间界于表锁和行锁之间;</li>
<li>会出现死锁;</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h2 id="4-5-锁优化建议"><a href="#4-5-锁优化建议" class="headerlink" title="4.5 锁优化建议"></a>4.5 锁优化建议</h2><ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能较少检索条件，避免间隙锁</li>
<li>尽量控制事务大小,减少锁定资源量和时间长度</li>
<li>尽可能低级别事务隔离</li>
</ul>
<h1 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h1><h2 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h2><p>slave会从master读取binlog来进行数据同步</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107215916362.png" srcset="/img/loading.gif" lazyload alt="image-20220107215916362"></p>
<ol>
<li>master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events;</li>
<li>slave将master的binary log events拷贝到它的中继日志(relay log）；</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</li>
</ol>
<blockquote>
<p>复制的基本原则</p>
</blockquote>
<ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个salve</li>
</ul>
<blockquote>
<p>复制的最大问题</p>
</blockquote>
<p>延时</p>
<h2 id="5-2-一主一从配置案例"><a href="#5-2-一主一从配置案例" class="headerlink" title="5.2 一主一从配置案例"></a>5.2 一主一从配置案例</h2><ol>
<li><p>MySQL版本尽量一致，版本号前两段必须相同。同时互相必须能ping通</p>
</li>
<li><p>主机修改配置文件</p>
<ol>
<li><strong>必须:</strong> 主服务器唯一ID：server-id=1</li>
<li><strong>必须：</strong>启用二进制日志：log-bin = 本地路径/mysqlbin</li>
<li>启用错误日志：log-err = 本地路径/mysqlerr</li>
<li>根目录：basedir = “本地路径”</li>
<li>临时目录：tmpdir = “本地路径”</li>
<li>数据目录：datadir = “本地路径/Data”</li>
<li>read-only = 0 ,代表主机读写都可以</li>
<li>设置不要复制的数据库：binlog-ignore-db = 数据库名列表</li>
<li>设置需要复制的数据库：binlog-do-db = 数据库名列表</li>
</ol>
</li>
<li><p>从机修改配置文件</p>
<ol>
<li><strong>必须:</strong> 从机服务器唯一ID ：service-id = 2</li>
<li>[建议] 启用二进制日志</li>
</ol>
</li>
<li><p>重启主从机MySQL数据库</p>
</li>
<li><p>主从机关闭防火墙</p>
</li>
<li><p>在<strong>主机</strong>上建立账户并授权slave</p>
<ol>
<li><p>```sql<br>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘账户名‘@’从机数据库IP’ IDENTIFIED BY ‘账户密码’;<br>flush privileges; # 刷新<br>SHOW master status; # 查询Master的状态，并记录下File和Position的值！</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>   2. 操作完上述步骤后，不再操作主服务器MySQL，防止主服务器状态值变化<br><br>7. 在**从机**上配置需要复制的主机<br><br>   1. ```sql<br>      # 登录主机账户<br>      CHANGE MASTER <span class="hljs-keyword">TO</span> <span class="hljs-attribute">MASTER_HOST</span>=<span class="hljs-string">&#x27;主机IP&#x27;</span>,<br>      <span class="hljs-attribute">MASTER_USER</span>=<span class="hljs-string">&#x27;账户名&#x27;</span>,<br>      <span class="hljs-attribute">MASTER_PASSWORD</span>=<span class="hljs-string">&#x27;账户密码&#x27;</span>,<br>      <span class="hljs-attribute">MASTER_LOG_FILE</span>=<span class="hljs-string">&#x27;6.1步骤中记录下的File值&#x27;</span>,<br>      <span class="hljs-attribute">MASTER_LOG_POS</span>=<span class="hljs-string">&#x27;6.1步骤中记录下的Position值&#x27;</span>;<br>      # 启动从服务器复制功能<br>      START SLAVE;<br></code></pre></td></tr></table></figure></li>
<li><p>使用<code>Show slave status\G</code>命令，若<code>Slave_IO_Running:Yes</code>且<code>Slave_SQL_Running:Yes</code>则主从配置成功</p>
</li>
</ol>
</li>
<li><p>停止从服务复制功能：<code>stop slave;</code></p>
</li>
</ol>
<p>7.2 中可能出现某一项不为Yes，解决方法：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220107223918622.png" srcset="/img/loading.gif" lazyload alt="image-20220107223918622"></p>
<h1 id="附录A-MySQL文件结构"><a href="#附录A-MySQL文件结构" class="headerlink" title="附录A MySQL文件结构"></a>附录A MySQL文件结构</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220101131308574.png" srcset="/img/loading.gif" lazyload alt="image-20220101131308574"></p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220101131534062.png" srcset="/img/loading.gif" lazyload alt="image-20220101131534062"></p>
<ul>
<li>二进制日志log-bin :主从复制</li>
<li>错误日志log-error：默认是关闭的,记录严玉的警告和告误信息，每次启动和关闭的详细信息等。</li>
<li>查询日志log：默认关闭，记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的</li>
<li>数据文件<ul>
<li>位置：<ul>
<li>windows data日录下可以祧选很多库</li>
<li>linux 默认路径:fvarflibfmysql</li>
</ul>
</li>
<li>frm文件 ：存放表结构</li>
<li>myd文件：存放表数据</li>
<li>myi文件：存放表索引</li>
</ul>
</li>
<li>配置文件<ul>
<li>windows：my.ini文件</li>
<li>Linux：/etc/my.cnf文件</li>
</ul>
</li>
</ul>
<h1 id="附录B-MySQL的隔离级别"><a href="#附录B-MySQL的隔离级别" class="headerlink" title="附录B MySQL的隔离级别"></a>附录B MySQL的隔离级别</h1><p>==在读懂本案例的前提是，你已经明白了事务是什么，下述的问题都出现在一个事务当中，而不是某次操作==</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327102850878.png" srcset="/img/loading.gif" lazyload alt="image-20220327102850878" style="zoom:67%;" />

<p>只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。</p>
<h2 id="1、读未提交"><a href="#1、读未提交" class="headerlink" title="1、读未提交"></a>1、读未提交</h2><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而<strong>读未提交隔离级别是不加锁的</strong>，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。</p>
<p>任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。</p>
<p>读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，<strong>如果中间发生回滚，那就会出现脏数据问题</strong>，读未提交没办法解决脏数据问题。</p>
<h2 id="2、读提交"><a href="#2、读提交" class="headerlink" title="2、读提交"></a>2、读提交</h2><p>既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。</p>
<p>读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 Oracle，但是不是 MySQL 的默认隔离界别。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327103136736.png" srcset="/img/loading.gif" lazyload alt="image-20220327103136736" style="zoom:50%;" />

<p>每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。即本案例事务B中，前两个 SELECT 和第三个的查询结果是不一致的</p>
<p>读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。</p>
<h2 id="3、可重复读"><a href="#3、可重复读" class="headerlink" title="3、可重复读"></a>3、可重复读</h2><p>可重复是对比不可重复而言的，不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，<strong>事务不会读到其他事务对已有数据的修改，即使其他事务已提交</strong>，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327103522717.png" srcset="/img/loading.gif" lazyload alt="image-20220327103522717" style="zoom:50%;" />

<p>可重复读做到了，这只是针对已有行的更改操作有效，但是对于新插入的行记录，幻读就产生了</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327103903244.png" srcset="/img/loading.gif" lazyload alt="image-20220327103903244" style="zoom:50%;" />

<p>在事务A commit之前，第二个SELECT读到的数据比第一次SELECT多一条数据！</p>
<h2 id="4、串行化"><a href="#4、串行化" class="headerlink" title="4、串行化"></a>4、串行化</h2><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。<strong>效率极低</strong></p>
<h1 id="附录C-MVCC"><a href="#附录C-MVCC" class="headerlink" title="附录C MVCC"></a>附录C MVCC</h1><p>==为了解决不可重复读，或者为了实现可重复读，MySQL 采用了 MVCC (Multi-Version Concrrent Control多版本并发控制) 的方式。==</p>
<p>它的实现原理主要是<strong>版本链，undo日志 ，Read View</strong></p>
<p>我们在数据库表中看到的<strong>一行记录可能实际上有多个版本</strong>，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为<code>row trx_id</code>，而这个字段就是使其产生的事务的 id，事务 ID 记为 <code>transaction id</code>，它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p>
<ul>
<li><strong>6字节的事务ID(DB_TRX_ID)字段</strong>：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。</li>
<li><strong>7字节的回滚指针(DB_ROLL_PTR)字段</strong>：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</li>
<li><strong>6字节的DB_ROW_ID字段</strong>：包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>
</ul>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327105002757.png" srcset="/img/loading.gif" lazyload alt="image-20220327105002757" style="zoom:50%;" />

<p><strong>快照</strong>，学名叫做<strong>一致性视图</strong>，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p>
<p>对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：</p>
<ol>
<li>当前事务内的更新，可以读到；</li>
<li>版本未提交，不能读到；</li>
<li>版本已提交，但是却在快照创建后提交的，不能读到；</li>
<li>版本已提交，且是在快照创建前提交的，可以读到；</li>
</ol>
<ul>
<li><p>快照读：读取的是快照版本，也就是历史版本。简单的select操作(不包括 select … lock in share mode, select … for update)</p>
</li>
<li><p>当前读：读取的是最新版本。UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。</p>
</li>
</ul>
<h1 id="附录D-LBCC"><a href="#附录D-LBCC" class="headerlink" title="附录D LBCC"></a>附录D LBCC</h1><p>与附录C相对，LBCC (Lock-Based Concrrent Control)是基于锁的并发控制。如果仅仅是基于锁来实现事务隔离，一个事务读取的时候不允许其他时候修改，那 就意味着不支持并发的读写操作，而我们的大多数应用都是读多写少的，这样会极大地 影响操作数据的效率。</p>
<ul>
<li>锁定力度：表锁 &gt; 行锁</li>
<li>加锁效率：表锁 &gt; 行锁</li>
<li>冲突概率：表锁 &gt; 行锁</li>
<li>并发性能：表锁 &lt; 行锁</li>
</ul>
<p>innodb的行锁是通过给索引项加锁实现的,这就意味着只有通过<strong>索引</strong>条件检索数据时,innodb才使用行锁,否则使用表锁。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">官方八锁</a></p>
</blockquote>
<ul>
<li>乐观锁、互斥锁(共享和独占/排他 锁)(Shard and Exclusive Locks, 行级锁)</li>
<li>意向锁(Intention Locks, 表级锁)</li>
<li>记录锁/行锁 (Record Locks, 行级锁)</li>
<li>间隙锁 (Gap Locks, 行级锁)</li>
<li>临键锁 (Next-key Locksl, 行级锁) (Record Locks + Gap Locks )</li>
<li>插入意向锁(Insert Intention Locks, 行级锁)</li>
<li>自增锁(AUTO-INC Locks, 表级锁)</li>
<li>空间索引的谓词锁 </li>
</ul>
<h2 id="D1-Shard-And-Exclusive-Locks"><a href="#D1-Shard-And-Exclusive-Locks" class="headerlink" title="D1 Shard And Exclusive Locks"></a>D1 Shard And Exclusive Locks</h2><p>行级锁定,其中有两种类型的锁：共享锁、独占锁</p>
<ul>
<li>共享(S)锁允许持有锁的事务读取一行。</li>
<li>排他(X)锁允许持有锁的事务更新或删除行</li>
</ul>
<p>如果事务<code>T1</code>在行<code>r</code>上持有共享(<code>S</code>)锁，则来自某些不同事务<code>T2</code>的对行<code>r</code>的锁请求将按以下方式处理：</p>
<ul>
<li><code>T2</code>对<code>S</code>锁定的请求可以立即获得批准。结果，<code>T1</code>和<code>T2</code>都在<code>r</code>上保持<code>S</code>锁定。</li>
<li><code>T2</code>对<code>X</code>锁定的请求无法立即获得批准。</li>
</ul>
<p>如果事务<code>T1</code>在行<code>r</code>上拥有排他(<code>X</code>)锁，则不能立即批准来自某个不同事务<code>T2</code>的对<code>r</code>上任一类型的锁的请求。相反，事务<code>T2</code>必须 await 事务<code>T1</code>释放对行<code>r</code>的锁定。</p>
<h2 id="D2-Intention-Locks"><a href="#D2-Intention-Locks" class="headerlink" title="D2 Intention Locks"></a>D2 Intention Locks</h2><p><strong>InnoDB 支持多重粒度，它允许行锁和表锁并存,意向锁是一种不与行级锁冲突表级锁</strong>。例如，<code>LOCK TABLES ... WRITE</code> 之类的语句在指定的table上具有排他锁。为了使在多个粒度级别上的锁定切实可行，<code>InnoDB</code>使用意向锁(Intention Locks)。==意向锁是 table 级锁==，指示事务稍后对 table 中的行需要哪种类型的锁(共享锁或排他锁)。</p>
<p>加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。</p>
<p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个<strong>意向共享锁</strong>。如果需要的是某行（或者某些行）的排他锁定，则申请一个<strong>意向排他锁</strong>。</p>
<p>有两种类型的意图锁：</p>
<ul>
<li><p>意向共享锁(IS) 表示事务打算对table中的各个行设置共享锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE; <br></code></pre></td></tr></table></figure></li>
<li><p>意向排他锁(IX) 表示事务打算对table中的各个行设置排他锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; <br></code></pre></td></tr></table></figure></li>
</ul>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p>意向锁定协议：</p>
<ul>
<li>在事务可以获取 table 中某行的共享锁之前，它必须首先获取该 table 中的<code>IS</code>锁或更强的锁。</li>
<li>在事务可以获取 table 中某行的排它锁之前，它必须首先获取该 table 中的<code>IX</code>锁。</li>
</ul>
<blockquote>
<p>兼容性</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th><code>X</code></th>
<th><code>IX</code></th>
<th><code>S</code></th>
<th><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>X</code></td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td><code>IX</code></td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td><code>S</code></td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td><code>IS</code></td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<blockquote>
<p>举例</p>
</blockquote>
<p>事务A锁住表中的一行(写锁)</p>
<p>事务B锁住整个表(写锁)</p>
<ul>
<li>出现的问题：事务A既然锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！！</li>
</ul>
<p>使用意向锁后，事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。</p>
<p>事务 A 获取了某一行的排他锁，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<p>此时 users 表存在两把锁：</p>
<ol>
<li>users 表上的<strong>意向排他锁</strong></li>
<li>id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>事务 B 想要获取 users 表的共享锁(表级)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK TABLES users READ;<br></code></pre></td></tr></table></figure>

<p>此时事务 B 检测事务 A 持有 users 表的<strong>意向排他锁</strong>，就可以得知事务 A 必然持有该表中某些数据行的<strong>排他锁</strong>，那么事务 B 对 users 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p>
<p>最后事务 C 也想获取 users 表中某一行的排他锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure>

<ol>
<li>事务 C 申请 users 表的<strong>意向排他锁</strong>。</li>
<li>事务 C 检测到事务 A 持有 users 表的<strong>意向排他锁</strong>。</li>
<li>因为意向锁之间并不互斥，所以事务 C 获取到了 users 表的<strong>意向排他锁</strong>。</li>
<li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终事务 C 成功获取到了该数据行上的<strong>排他锁</strong>。</li>
</ol>
<h2 id="D3-Record-Locks"><a href="#D3-Record-Locks" class="headerlink" title="D3 Record Locks"></a>D3 Record Locks</h2><p>==InnoDB三种行锁算法之一==。单个行记录上的锁。</p>
<p>记录锁是对索引记录的锁定（<strong>行锁</strong>）。例如，<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code>阻止任何其他事务插入，更新或删除<code>t.c1</code>的值为<code>10</code>的行。</p>
<p>记录锁始终锁定索引记录，即使没有定义索引的 table 也是如此。在这种情况下，<code>InnoDB</code>将创建一个隐藏的聚集索引，并将该索引用于记录锁定。</p>
<h2 id="D4-Gap-Locks"><a href="#D4-Gap-Locks" class="headerlink" title="D4 Gap Locks"></a>D4 Gap Locks</h2><p>==InnoDB三种行锁算法之一==。目的是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>间隙锁是对索引记录之间的间隙的锁定，或者是对第一个或最后一个索引记录之前的间隙的锁定。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>防止其他事务将<code>15</code>的值插入到<code>t.c1</code>列中，无论该列中是否已经有这样的值，因为该范围中所有现有值之间的间隙都被锁定。</p>
<p>间隙可能跨越单个索引值，多个索引值，甚至为空。间隙锁是性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别中使用。</p>
<p><strong>值得注意的是</strong>：对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。例如，如果<code>id</code>列具有唯一索引，则以下语句仅使用具有<code>id</code>值 100 的行的索引记录锁，其他会话是否在前面的间隙中插入行都没有关系：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> child <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>

<p>如果<code>id</code>未构建索引或索引不唯一，则该语句会锁定前面的间隙。即锁定(- ∞ ，100]的行</p>
<p>如果将事务隔离级别更改为READ COMMITTED，将禁用间隙锁定进行搜索和索引扫描，并且仅将其用于外键约束检查和重复键检查。</p>
<h2 id="D5-Next-Key-Locks"><a href="#D5-Next-Key-Locks" class="headerlink" title="D5 Next-Key Locks"></a>D5 Next-Key Locks</h2><p>==InnoDB三种行锁算法之一==。对于行的查询，都是采用该方法，innodb默认的锁就是Next-Key locks。主要目的是解决幻读的问题。</p>
<p>临键锁 是索引记录上的记录锁(行锁)和索引记录之前的间隙上的间隙锁定的组和 </p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220328203808540.png" srcset="/img/loading.gif" lazyload alt="image-20220328203808540"></p>
<h2 id="D6-Insert-Intention-Locks"><a href="#D6-Insert-Intention-Locks" class="headerlink" title="D6 Insert Intention Locks"></a>D6 Insert Intention Locks</h2><p>插入意图锁是一种在行插入之前通过 INSERT 操作设置的间隙锁定。此锁发出插入意图的 signal 是，如果多个事务未插入间隙中的相同位置，则无需 await 彼此插入的多个事务。假设有索引记录，其值分别为 4 和 7.单独的事务分别尝试插入值 5 和 6，在获得插入行的排他锁之前，每个事务都使用插入意图锁来锁定 4 和 7 之间的间隙，但不要互相阻塞，因为行是无冲突的。</p>
<p>插入意向锁本质上可以看成是一个<code>Gap Lock</code></p>
<ul>
<li>普通的Gap Lock 不允许 在 （上一条记录，本记录） 区间范围内插入数据。</li>
<li>插入意向锁Gap Lock 允许 在 （上一条记录，本记录） 区间范围内插入数据。</li>
</ul>
<p>插入意向锁的作用是为了<strong>提高并发插入的性能</strong>， 多个事务 同时写入 不同数据 至同一索引范围（区间）内，并不需要等待其他事务完成，不会发生锁等待。</p>
<blockquote>
<p>举例</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Time</td>
<td align="center">会话A</td>
<td align="center">会话B</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">begin</td>
<td align="center">begin</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">select * from a where a&lt;=13 for update</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center">insert into a values (12)<br/>– waiting…… （被阻塞了，在这里等待）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">commit</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center">输出：Query OK, 1 row affected<br/>前提条件：insert操作的锁没有超时</td>
</tr>
</tbody></table>
<p>此时事务B插入成功但是还未commit，再执行<code>show engine innodb status\G</code>语句，会有以下输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">---TRANSACTION 4425, ACTIVE 26 sec</span><br><span class="hljs-number">2</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">1</span> <span class="hljs-type">row</span> lock(s), undo log entries <span class="hljs-number">1</span><br>MySQL thread id <span class="hljs-number">3</span>, OS thread handle <span class="hljs-number">140018685810432</span>, query id <span class="hljs-number">247</span> localhost root<br><span class="hljs-keyword">TABLE</span> LOCK <span class="hljs-keyword">table</span> `test`.`a` trx id <span class="hljs-number">4425</span> lock mode IX<br><br>RECORD LOCKS space id <span class="hljs-number">37</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> n bits <span class="hljs-number">72</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `test`.`a` trx id <span class="hljs-number">4425</span> lock_mode X locks gap before rec <span class="hljs-keyword">insert</span> intention<br><br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> PHYSICAL RECORD: n_fields <span class="hljs-number">3</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">8000000</span>d; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000001140</span>; <span class="hljs-keyword">asc</span>      @;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex b400000128011c; <span class="hljs-keyword">asc</span>     (  ;;<br></code></pre></td></tr></table></figure>

<p>从上面的输出可以看到在记录13 上面加了一把插入意图锁（<code>lock_mode X locks gap before rec insert intention</code>）。</p>
<p>获得插入意图锁之后，我们就可以在11-13之间并发插入记录，而不需要一个事物等待另一事物，当所有相关的插入的事物都提交后， 13上的插入意向锁 便会释放。</p>
<p>假如没有插入意向锁，而是用普通的间隙锁。插入数据时会获取这条记录所在区间的间隙锁及这条记录的排它锁，其他事务是不可能在这个区间内插入数据的，因为当前事务已经获取了这个区间内的间隙锁，其他事务无法获取对应记录的排它锁，只能等待其他事务完成；</p>
<p>用插入意向锁后，数据库设计插入意向锁与排它锁不互斥。多个事务既可以获取对应区间的插入意向锁也可以获取对应记录的排它锁，各个事务互不影响，不需要等待其他事务完成后才能进行插入。</p>
<h2 id="D7-AUTO-INC-Locks"><a href="#D7-AUTO-INC-Locks" class="headerlink" title="D7 AUTO-INC Locks"></a>D7 AUTO-INC Locks</h2><p>在InnoDB中，每个含有自增列的表都有一个自增长计数器。当对含有自增长计数器的表进行插入时，首先会执行<code>select max(auto_inc_col) from t for update</code>来得到计数器的值，然后再将这个值加1赋予自增长列。我们将这种方式称之为<code>AUTO_INC Lock</code></p>
<p><code>AUTO-INC</code>锁是一种特殊的 table 级锁，由事务插入具有<code>AUTO_INCREMENT</code>列的 table 中获得。在最简单的情况下，如果一个事务正在向 table 中插入值，那么任何其他事务都必须 await 自己在该 table 中进行插入，以便第一个事务插入的行接收连续的主键值。</p>
<p>从MySQL 5.1.22开始，InnoDB中提供了一种轻量级互斥量的自增长实现机制，同时InnoDB存储引擎提供了一个参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，进而提高自增长值插入的性能。<code>innodb_autoinc_lock_mode</code>和插入类型有关</p>
<p>innodb_autoinc_lock_mode值:</p>
<p><strong>innodb_autoinc_lock_mode = 0 传统模式</strong>，所有的插入语句在开始的时候都需要先获取自增锁，语句结束之后才释放自增自增锁，最安全但并发性最差。</p>
<p><strong>innodb_autoinc_lock_mode = 1 连续模式</strong>，InnoDB 中默认的方式，该模式对于可预测插入行数的插入进行了优化，一次可以批量生成连续的值。</p>
<p><strong>innodb_autoinc_lock_mode = 2 交错模式</strong>，在这种锁定模式下，没有使用表级的自增锁，因此它的速度是最快的。但是该模式下并不能保证生成的值是连续，因此在主从复制或数据恢复的时候，主键可能与之前产生的不一致。</p>
<p>插入类型：</p>
<ul>
<li><p>“INSERT-like” statements</p>
<p>泛指所有的插入语句, 它包括 “simple-inserts”, “bulk-inserts”, 和 “mixed-mode inserts”.</p>
</li>
<li><p>“Simple inserts”</p>
<p>插入的记录行数是确定的：比如：insert into values，replace<br>但是不包括： INSERT … ON DUPLICATE KEY UPDATE.</p>
</li>
<li><p>“Bulk inserts”</p>
<p>插入的记录行数不能马上确定的，比如： INSERT … SELECT, REPLACE … SELECT, and LOAD DATA</p>
</li>
<li><p>“Mixed-mode inserts”</p>
<p>这些都是simple-insert，但是部分auto increment值给定或者不给定. 例子如下(where <code>c1</code> is an <code>AUTO_INCREMENT</code> column of table <code>t1</code>):</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 (c1,c2) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;c&#x27;</span>), (<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;d&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>另外一种 “mixed-mode insert” 就是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code></p>
</li>
</ul>
<h2 id="D8-Predicate-Locks-for-Spatial-Indexes"><a href="#D8-Predicate-Locks-for-Spatial-Indexes" class="headerlink" title="D8 Predicate Locks for Spatial Indexes"></a>D8 Predicate Locks for Spatial Indexes</h2><p>在多维空间数据中，没有绝对排序的概念，因此之前引入的间隙锁机制不能有效的处理空间数据的数据隔离。为此 InnoDB 中引入了空间索引谓词锁的机制，空间索引采用的是R-Tree 数据结构实现，空间索引包含了最小矩形边界的数据(MBR)，因此 InnoDB 可以通过在 MBR 上加谓词锁来保证一致性读。</p>
<blockquote>
<p>优化空间分析</p>
</blockquote>
<p>对于<code>MyISAM</code>和<code>InnoDB</code>table，可以使用<code>SPATIAL</code>索引优化包含空间数据的列中的搜索操作。最典型的操作是：</p>
<ul>
<li>点查询，搜索包含给定点的所有对象</li>
<li>区域查询搜索与给定区域重叠的所有对象</li>
</ul>
<p>MySQL 对空间列上的<code>SPATIAL</code>索引使用具有二次分裂的 R 树。使用几何的最小边界矩形(MBR)构建<code>SPATIAL</code>索引。对于大多数几何图形，MBR 是围绕几何图形的最小矩形。对于水平或垂直线串，MBR 是退化为线串的矩形。对于一个点，MBR 是退化为该点的矩形。</p>
<p>也可以在空间列上创建普通索引。在非<code>SPATIAL</code>索引中，必须为除<code>POINT</code>列之外的任何空间列声明前缀。</p>
<h1 id="附录E-B树、B-树和B-树"><a href="#附录E-B树、B-树和B-树" class="headerlink" title="附录E B树、B+树和B*树"></a>附录E B树、B+树和B*树</h1><p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因是当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。这说明程序大部分时间会阻塞在磁盘 IO 上。减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>
<p>B的全程是Blance，平衡的意思</p>
<ul>
<li>B/B- 树：多路搜索树，每个节点存储M/2到M个关键字，非叶子节点存储指向关键字范围的子节点；所有关键字在整棵树中出现，并且只出现一次，非叶子节点可以命中。每个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点</li>
<li>B+树：在B-树的基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现，非叶子节点作为叶子节点的索引；B+树总时到叶子节点才命中。</li>
<li>B*树：在B+树的基础上，为非叶子节点也增加链表指针，将节点的最低利用率从1/2提高到2/3</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B树模拟</a></p>
<h2 id="E1-B-B-树"><a href="#E1-B-B-树" class="headerlink" title="E1 B/B- 树"></a>E1 B/B- 树</h2><p>B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的，查询的时间复杂度是log2(n)；其次是构造一个多阶B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息；<br><strong>总结：利用平衡树的优势加快查询的稳定性和速度。</strong></p>
<p>一个 m 阶的B树满足以下条件：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<blockquote>
<p>插入流程</p>
</blockquote>
<ul>
<li>如果该结点的关键字个数没有到达m-1个，那么直接插入即可；</li>
<li>如果该结点的关键字个数已经到达了m-1个，那么根据B树的性质显然无法满足，需要将其进行分裂。<ul>
<li>分裂的规则是该结点分成两半，将中间的关键字进行提升，加入到父亲结点中，但是这又可能存在父亲结点也满员的情况，则不得不向上进行回溯，甚至是要对根结点进行分裂，那么整棵树都加了一层。</li>
</ul>
</li>
</ul>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329173242591.png" srcset="/img/loading.gif" lazyload alt="image-20220329173242591" style="zoom: 33%;" />



<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329173326184.png" srcset="/img/loading.gif" lazyload alt="image-20220329173326184" style="zoom:33%;" />

<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329173341294.png" srcset="/img/loading.gif" lazyload alt="image-20220329173341294" style="zoom:33%;" />



<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329173352093.png" srcset="/img/loading.gif" lazyload alt="image-20220329173352093" style="zoom:33%;" />

<blockquote>
<p>删除流程</p>
</blockquote>
<p>同样的，我们需要先通过搜索找到相应的值，存在则进行删除，需要考虑删除以后的情况，</p>
<ul>
<li>如果该结点拥有关键字数量仍然满足B树性质，则不做任何处理；</li>
<li>如果该结点在删除关键字以后不满足B树的性质（关键字没有到达ceil(m/2)-1的数量），则需要向兄弟结点借关键字，这有分为兄弟结点的关键字数量是否足够的情况。<ul>
<li>如果兄弟结点的关键字足够借给该结点，则过程为将父亲结点的关键字下移，兄弟结点的关键字上移；</li>
<li>如果兄弟结点的关键字在借出去以后也无法满足情况，即之前兄弟结点的关键字的数量为ceil(m/2)-1，借的一方的关键字数量为ceil(m/2)-2的情况，那么我们可以将该结点合并到兄弟结点中，合并之后的子结点数量少了一个，则需要将父亲结点的关键字下放，如果父亲结点不满足性质，则向上回溯；</li>
</ul>
</li>
<li>其余情况参照BST中的删除。</li>
</ul>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329185544139.png" srcset="/img/loading.gif" lazyload alt="image-20220329185544139" style="zoom: 50%;" />

<p><strong>索引的效率依赖与磁盘 IO 的次数，快速索引需要有效的减少磁盘 IO 次数</strong>，如何快速索引呢？索引的原理其实是不断的缩小查找范围，就如我们平时用字典查单词一样，先找首字母缩小范围，再第二个字母等等。平衡二叉树是每次将范围分割为两个区间。为了更快，<strong>B-树每次将范围分割为多个区间，区间越多，定位数据越快越精确。那么如果节点为区间范围，每个节点就较大了</strong>。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329190949543.png" srcset="/img/loading.gif" lazyload alt="image-20220329190949543" style="zoom:67%;" />



<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<ol>
<li>关键字集合分布在整棵树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<h2 id="E2-B-树"><a href="#E2-B-树" class="headerlink" title="E2 B+ 树"></a>E2 B+ 树</h2><p>B+树是B-树的变体，也是一种多路搜索树。</p>
<p>其定义基本与B-树同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li><strong>为所有叶子结点增加一个链指针；</strong></li>
<li><strong>所有关键字都在叶子结点出现；</strong></li>
</ol>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329191140863.png" srcset="/img/loading.gif" lazyload alt="image-20220329191140863" style="zoom:67%;" />

<p><strong>因为内节点并不存储 data，所以一般B+树的叶节点和内节点大小不同，而B-树的每个节点大小一般是相同的，为一页。</strong></p>
<blockquote>
<p>B+ 树和 B- 树的区别</p>
</blockquote>
<ul>
<li><p>B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)</p>
<p>如下：B-树/B+树查询节点 key 为 50 的 data</p>
<ul>
<li><p>B-树</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329191428818.png" srcset="/img/loading.gif" lazyload alt="image-20220329191428818" style="zoom:67%;" /></li>
<li><p>B+树</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329191450289.png" srcset="/img/loading.gif" lazyload alt="image-20220329191450289" style="zoom:67%;" /></li>
<li><p>key 为 50 的节点就在第一层，B-树只需要一次磁盘 IO 即可完成查找。<strong>由于B+树所有的 data 域都在根节点，所以查询 key 为 50的节点必须从根节点索引到叶节点，时间复杂度固定为 O(log n)。</strong></p>
</li>
</ul>
</li>
<li><p>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</p>
<ul>
<li><p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p>
</li>
<li><p>B+树可以很好的利用局部性原理，若我们访问节点 key为 50，则 key 为 55、60、62 的节点将来也可能被访问，<strong>我们可以利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数。</strong></p>
</li>
</ul>
</li>
<li><p>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</p>
<p>由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，<strong>那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大</strong>。<strong>这就意味着B+树单次磁盘 IO 的信息量大于B-树</strong>，从这点来看B+树相对B-树磁盘 IO 次数少。</p>
</li>
</ul>
<h2 id="E3-B-树"><a href="#E3-B-树" class="headerlink" title="E3 B * 树"></a>E3 B * 树</h2><p><strong>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</strong></p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h2 id="E4-MySQL为什么使用B-Tree（B-Tree）"><a href="#E4-MySQL为什么使用B-Tree（B-Tree）" class="headerlink" title="E4 MySQL为什么使用B-Tree（B+Tree）"></a>E4 MySQL为什么使用B-Tree（B+Tree）</h2><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。这需要结合计算机组成原理相关知识讨论B - /+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</strong></p>
<blockquote>
<p>存储数据最小单元</p>
</blockquote>
<p>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k</p>
<p>InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K(可以通过参数<code>innodb_page_size</code>设置)。</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329194723833.png" srcset="/img/loading.gif" lazyload alt="image-20220329194723833"></p>
<p>假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。</p>
<blockquote>
<p>主存存取原理</p>
</blockquote>
<p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220329195045145.png" srcset="/img/loading.gif" lazyload alt="image-20220329195045145" style="zoom: 25%;" />

<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。</p>
<p>主存的存取过程如下：</p>
<ol>
<li>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</li>
<li>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</li>
<li>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取<code>A0</code>再取<code>A1</code>和先取<code>A0</code>再取<code>D3</code>的时间消耗是一样的。</li>
</ol>
<blockquote>
<p>磁盘存取原理</p>
</blockquote>
<p>索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，<strong>每个段叫做一个扇区，每个扇区是磁盘的最小存储单元</strong>。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<blockquote>
<p>局部性原理和磁盘预读</p>
</blockquote>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是<strong>每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<ul>
<li><strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></li>
</ul>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。<strong>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k）</strong>，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p><strong>所以IO一次就是读一页的大小</strong></p>
<h1 id="附录F-MySQL的在可重复读级别下幻读的解决方案"><a href="#附录F-MySQL的在可重复读级别下幻读的解决方案" class="headerlink" title="附录F MySQL的在可重复读级别下幻读的解决方案"></a>附录F MySQL的在可重复读级别下幻读的解决方案</h1><p>==解决办法：MySQL的间隙锁==</p>
<p>在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327104734292.png" srcset="/img/loading.gif" lazyload alt="image-20220327104734292" style="zoom:33%;" />

<blockquote>
<p>案例</p>
</blockquote>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220327104616851.png" srcset="/img/loading.gif" lazyload alt="image-20220327104616851" style="zoom:50%;" />

<p>本案例中，在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。</p>
<p>当事务A执行<code>update user set name=&#39;风筝2号’ where age = 10;</code> 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。</p>
<p>不仅插入 age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。</p>
<p><strong>值得注意的是</strong>：这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。</p>
<h1 id="附录G-MySQL中的日志"><a href="#附录G-MySQL中的日志" class="headerlink" title="附录G MySQL中的日志"></a>附录G MySQL中的日志</h1><ul>
<li><strong>undo log</strong>：是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。<ul>
<li>undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；</li>
<li>与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。</li>
</ul>
</li>
<li><strong>redo log</strong>：确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。<ul>
<li>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</li>
</ul>
</li>
<li><strong>bin log</strong>：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。<ul>
<li>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。而且还包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</li>
</ul>
</li>
<li><strong>general query log</strong>：普通查询日志。记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 ，记录的格式为 {Time ，Id ，Command，Argument }。Mysql默认是把General log关闭的。</li>
<li><strong>错误日志：</strong>记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</li>
<li><strong>慢查询日志：</strong>记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。(在前面索引优化部分有讲解)</li>
</ul>
<h1 id="附录H-聚集索引和非聚集索引解析"><a href="#附录H-聚集索引和非聚集索引解析" class="headerlink" title="附录H 聚集索引和非聚集索引解析"></a>附录H 聚集索引和非聚集索引解析</h1><p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</strong></p>
<h2 id="H1-聚集索引"><a href="#H1-聚集索引" class="headerlink" title="H1 聚集索引"></a>H1 聚集索引</h2><p>聚集索引表记录的排列顺序和索引的排列顺序一致(即索引的物理地址顺序和主键的逻辑顺序一致)，所以<strong>查询效率快</strong>，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是<strong>修改慢</strong>，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<strong>因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个</strong>。</p>
<h2 id="H2-非聚集索引"><a href="#H2-非聚集索引" class="headerlink" title="H2 非聚集索引"></a>H2 非聚集索引</h2><p>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致（在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的），两种索引都采用B+树结构，<strong>非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。</strong>非聚集索引层次多，不会造成数据重排。所以如果表的读操作远远多于写操作，那么就可以使用非聚集索引。</p>
<h2 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h2>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/DBA/">#DBA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL高级</div>
      <div>https://tridiamond.tech/post/MySQL高级.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 26, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/Java%208%E6%96%B0%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7.html" title="Java 8 特性及实战">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java 8 特性及实战</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html" title="Java开发手册">
                        <span class="hidden-mobile">Java开发手册</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
