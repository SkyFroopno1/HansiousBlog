
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexo || Java开发手册</title>
    <meta name="author" content="John Doe">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Hexo</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java开发手册 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/2/20
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java" style=color:#1bccbc>
                    Java
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>@author：韩霄杰(hanxj_a)</p>
<p>@date: 2022.02.20</p>
<p>@update:2022.03.14 / 2022.03.15 / </p>
<ul>
<li>NPE即 NullPointerException</li>
<li>JSL即《The Java Language Specification》</li>
<li>OOM即OutOfMemoryError</li>
<li>CME即ConcurrentModificationException</li>
<li>JMM即Java Memory Model</li>
<li>JVM即Java Virtual Machine</li>
<li>J.U.C即java.util.concurrent.* 包</li>
</ul>
<center>目录</center>

<p>[toc]</p>
<h1 id="一、三目运算符导致NPE的问题"><a href="#一、三目运算符导致NPE的问题" class="headerlink" title="一、三目运算符导致NPE的问题"></a>一、三目运算符导致NPE的问题</h1><h2 id="1-1-NPE触发"><a href="#1-1-NPE触发" class="headerlink" title="1.1 NPE触发"></a>1.1 NPE触发</h2><pre><code class="java">Integer a = 1;
Integer b = 2;
Integer c = null;
Boolean flag = false;
// a*b的结果是int类型，那么c会强制拆箱成int型，而c是null，因此会抛出NPE
Integer res = (flag ? a*b : c);
</code></pre>
<h2 id="1-2-基础知识"><a href="#1-2-基础知识" class="headerlink" title="1.2 基础知识"></a>1.2 基础知识</h2><ul>
<li>三目运算符</li>
<li>自动拆箱、自动装箱</li>
</ul>
<h3 id="1-2-1-三目运算符运算规则"><a href="#1-2-1-三目运算符运算规则" class="headerlink" title="1.2.1  三目运算符运算规则"></a>1.2.1  三目运算符运算规则</h3><p>三目运算符形式：</p>
<p><code>&lt;表达式1&gt; ？ &lt;表达式2&gt; : &lt;表达式3&gt;</code></p>
<p>通过<code>?</code>、<code>:</code>组合的形式得到一个条件表达式。其中<code>?</code>运算符的含义是：先求表达式 1 的值，</p>
<ul>
<li>若为真，执行并返回 表达式 2  的结果；</li>
<li>若为假，则执行并返回 表达式 3 的结果。</li>
</ul>
<p><strong>值得注意的是</strong>：一个条件表达式从不会既计算 &lt; 表达式 2&gt;，又计算 &lt; 表达式</p>
<p>3&gt;。条件运算符是右结合的，也就是说，从右向左分组计算。例如，a?b:c?d:e 将按</p>
<p>a?b:（c?d:e）执行</p>
<h3 id="1-2-2-自动拆箱和自动装箱"><a href="#1-2-2-自动拆箱和自动装箱" class="headerlink" title="1.2.2 自动拆箱和自动装箱"></a>1.2.2 自动拆箱和自动装箱</h3><p>自动装箱和自动拆箱是在Java SE5中，为方便基本数据类型和包装类之间的转换引入的功能。</p>
<pre><code class="java">Integer a = 10; // 自动装箱
int b = a;         // 自动拆箱
</code></pre>
<p><code>自动装箱</code>都是通过包装类的 valueOf() 方法来实现的</p>
<p><code>自动拆箱</code>都是通过包装类对象的 xxxValue() 来实现的（如 booleanValue()、longValue() 等）。</p>
<h2 id="1-3-原理刨析"><a href="#1-3-原理刨析" class="headerlink" title="1.3 原理刨析"></a>1.3 原理刨析</h2><h3 id="1-3-1-问题复现"><a href="#1-3-1-问题复现" class="headerlink" title="1.3.1 问题复现"></a>1.3.1 问题复现</h3><pre><code class="java">boolean flag = true;         // 设置成 true，保证条件表达式的表达式二一定可以执行
boolean simpleBoolean = false; // 定义一个基本数据类型的 boolean 变量
Boolean nullBoolean = null    ;// 定义一个包装类对象类型的 Boolean 变量，值为 null
boolean x = flag ? nullBoolean : simpleBoolean; // 使用三目运算符并给 x 变量赋值
</code></pre>
<p>对上述代码反编译后，可以得到：</p>
<pre><code class="java">boolean flag = true;        
boolean simpleBoolean = false;
Boolean nullBoolean = null;
boolean x = flag ? nullBoolean.booleanValue() : simpleBoolean;    // 注意点
</code></pre>
<p>反编译后的代码，最后一行进行了一次<code>自动拆箱</code>，而nullBollean是null，null调用booleanValue()方法导致NPE。</p>
<p><strong>需要注意的是</strong>：根据三目运算符运算规则，NPE产生，和flag 以及 nullBoolean的位置有关，若flag = false;那当nullBoolean在<code>:</code>后时，才会导致NPE。</p>
<h3 id="1-3-2-原理分析"><a href="#1-3-2-原理分析" class="headerlink" title="1.3.2 原理分析"></a>1.3.2 原理分析</h3><p>根据《JLS》-15.25 相关介绍：</p>
<ul>
<li>当三目运算符&lt;表达式2&gt;和&lt;表达式3&gt;操作数的类型相同(如都是包装类)时，则三目运算符表达式的结果和这两位操作数的类型相同。</li>
<li>当三目运算符&lt;表达式2&gt;和&lt;表达式3&gt;操作数中存在一个基本数据类型，那么该表达式的结果的类型要求是基本类型。如果不符合预期，那么编译器就会自动拆箱。</li>
</ul>
<h2 id="1-4-开发场景拓展"><a href="#1-4-开发场景拓展" class="headerlink" title="1.4 开发场景拓展"></a>1.4 开发场景拓展</h2><p>假设下述场景：</p>
<pre><code class="java">Map&lt;String,Boolean&gt; map = new HashMap&lt;String, Boolean&gt;();
Boolean b = (map!=null ? map.get(“test”) : false);
</code></pre>
<p>结果：在小于 JDK 1.8 的版本中执行的结果是 NPE，在 JDK 1.8 及以后的版本中执行结果是 null。</p>
<blockquote>
<p>JDK 8 新规范</p>
</blockquote>
<p>依据JDK8 后的《JLS》：(JDK8前没有这些规定)</p>
<ul>
<li>如果表达式的第二个和第三个操作数都是布尔表达式，那么该条件表达式就是布尔表达式</li>
<li>如果表达式的第二个和第三个操作数都是数字型表达式，那么该条件表达式就是数字型表达式</li>
<li>除了以上两种以外的表达式就是引用表达式</li>
</ul>
<p>因为第二个操作数为<code>map.get(&quot;test&quot;)</code>，虽然Map在定义时规定了其值类型为Boolean，但是在编译过程泛型会被擦除，因此其结果就是Object，即引用表达式。</p>
<ul>
<li>如果引用条件表达式出现在赋值上下文或调用上下文中，那么条件表达式就是合成表达式</li>
</ul>
<p>因为<code>Boolean b = (map!=null ? map.get(&quot;test&quot;) : false)</code>就时一个赋值上下文，所以<code>map!=null ? map.get(&quot;test&quot;) : false</code>是合成表达式</p>
<ul>
<li>合成的引用条件表达式的类型与其目标类型相同</li>
</ul>
<p>因此该表达式的第二个操作数和第三个操作数的结果应该都是 Boolean 类型，所以JDK 8以后的编译过程中，把他们都转化成Boolean，即：</p>
<pre><code class="java">Boolean b = maps == null ? Boolean.valueOf(false) : (Boolean)maps.get(&quot;test&quot;);
</code></pre>
<blockquote>
<p>会出现空指针异常的原因</p>
</blockquote>
<p>对上述代码反编译后：</p>
<pre><code class="java">HashMap hashmap = new HashMap();
Boolean boolean1 = Boolean.valueOf(hashmap == null ? false : ( (Boolean)hashmap.get(&quot;test&quot;) ).booleanValue() );
</code></pre>
<p>问题出现在：<code>((Boolean)hashmap.get(&quot;test&quot;)).booleanValue()</code>的执行过程中：</p>
<pre><code class="java">hashmap.get(&quot;test&quot;) -&gt; null; 
(Boolean) null -&gt; null;
null.booleanValue() -&gt; 报错NPE
</code></pre>
<blockquote>
<p>解决办法</p>
</blockquote>
<pre><code class="java">Map&lt;String,Boolean&gt; map = new HashMap&lt;&gt;();
Boolean b = (map!=null ? map.get(&quot;test&quot;) : Boolean.FALSE );
</code></pre>
<p>统一为包装类，map.get(“test”)就不会因此调用booleanValue()进行拆箱了。</p>
<h1 id="二、初始化HashMap容量的建议"><a href="#二、初始化HashMap容量的建议" class="headerlink" title="二、初始化HashMap容量的建议"></a>二、初始化HashMap容量的建议</h1><h2 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h2><p><em>参考《集合》中HashMap的扩容原理。</em></p>
<p>HashMap 类中有以下主要成员变量：</p>
<ul>
<li>transient int size;<ul>
<li>记录了 Map 中 KV 对的个数</li>
</ul>
</li>
<li>loadFactor<ul>
<li>装载印子，用来衡量 HashMap 满的程度。loadFactor 的默认值为 0.75f（static final float DEFAULT_LOAD_FACTOR = 0.75f;）</li>
</ul>
</li>
<li>int threshold;<ul>
<li>临界值，当实际 KV 个数超过 threshold 时，HashMap 会将容量扩容，threshold ＝容量 * 加载因子</li>
</ul>
</li>
<li>除了以上这些重要成员变量外，HashMap 中还有一个概念：capacity<ul>
<li>容量，如果不指定，默认容量是 16(static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;)</li>
</ul>
</li>
</ul>
<h2 id="2-2-建议"><a href="#2-2-建议" class="headerlink" title="2.2 建议"></a>2.2 建议</h2><p>在已知 HashMap 中将要存放的 KV 个数的时候，设置一个合理的初始化容量可以有效的提高性能。</p>
<p>默认情况下，当我们设置 HashMap的初始化容量时，实际上 HashMap 会采用第一个大于该数值的 2 的幂作为初始化容量。如我们<code> new HashMap&lt;String, String&gt;(1)</code>实际容量为2。</p>
<p><em>在 Jdk 1.7 和 Jdk 1.8 中，HashMap 初始化这个容量的时机不同。jdk1.8中，在调用 HashMap 的构造函数定义 HashMap 的时候，就会进行容量的设定。而在 Jdk 1.7 中，要等到第一次 put 操作时才进行这一操作。但计算初始化容量的算法基本相同</em></p>
<blockquote>
<p>初始化大小建议</p>
</blockquote>
<p>依据JDK 8 中putAll方法中的算法实现：<code> (int) ((float) expectedSize / 0.75F + 1.0F)</code>。我们可以认为，当我们明确知道 HashMap 中元素的个数的时候，把默认容量设置成 expectedSize / 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存</p>
<p><strong>值得注意的是</strong>：本操作是用内存换性能的做法，真正使用时需要考虑内存影响。</p>
<h1 id="三、禁止使用Executors创建线程池的原因"><a href="#三、禁止使用Executors创建线程池的原因" class="headerlink" title="三、禁止使用Executors创建线程池的原因"></a>三、禁止使用Executors创建线程池的原因</h1><h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h2><ul>
<li>线程池</li>
<li>阻塞队列</li>
</ul>
<h3 id="3-1-1-线程池"><a href="#3-1-1-线程池" class="headerlink" title="3.1.1 线程池"></a>3.1.1 线程池</h3><p>线程池技术：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-89-CcDnSLBYy3THmcLEdQ">《深入源码分析Java线程池的实现原理》</a></p>
<h3 id="3-1-2-阻塞队列"><a href="#3-1-2-阻塞队列" class="headerlink" title="3.1.2 阻塞队列"></a>3.1.2 阻塞队列</h3><p>BlockingQueue主要有两种实现：</p>
<ul>
<li>ArrayBlockingQueue<ul>
<li>是一个用<strong>数组实现</strong>的有界阻塞队列，必须设置容量</li>
</ul>
</li>
<li>LinkedBlockingQueue<ul>
<li>是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话将会是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。</li>
</ul>
</li>
</ul>
<h2 id="3-2-Executors存在的问题"><a href="#3-2-Executors存在的问题" class="headerlink" title="3.2 Executors存在的问题"></a>3.2 Executors存在的问题</h2><ul>
<li>FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量请求，从而导致OOM</li>
<li>CachedThreadPool和ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</li>
</ul>
<pre><code class="java">public class ExecutorsDemo &#123;
    private static ExecutorService executor = Executors.newFixedThreadPool(15);
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;
            executor.execute(new SubThread());
        &#125;
    &#125;
&#125;
class SubThread implements Runnable &#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(10000);
        &#125; catch (InterruptedException e) &#123;
            //do nothing
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过JVM参数：<code>-Xmx8m -Xms8m</code>运行，就会抛出OOM，抛错行数为5行<code>executor.execute(new SubThread())</code>处。</p>
<h2 id="3-3-Executors存在缺陷的原因"><a href="#3-3-Executors存在缺陷的原因" class="headerlink" title="3.3 Executors存在缺陷的原因"></a>3.3 Executors存在缺陷的原因</h2><p>通过报错信息，最直接导致OOM的是<code>LinkedBlockingQueue.offer()</code>方法。</p>
<p>底层实现：</p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) &#123;
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>
<p>由LinkedBlockingQueue的实现可知，这里未设置阻塞队列容量，因此将会是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p>
<h2 id="3-4-正确创建线程池"><a href="#3-4-正确创建线程池" class="headerlink" title="3.4 正确创建线程池"></a>3.4 正确创建线程池</h2><blockquote>
<p>方式一：</p>
</blockquote>
<p>避免使用Executors创建线程池，主要是避免使用其中的默认实现。那么可以自己直接调用ThreadPoolExecutor的构造函数自己创建线程池，只需要给BlockQueue指定容量就可以规避了。</p>
<pre><code class="java">private static ExecutorService executor = 
    new ThreadPoolExecutor(10, 10,
                           60L, TimeUnit.SECONDS,
                           new ArrayBlockingQueue(10));
</code></pre>
<p>此时只要提交的线程数超过当前可用线程数，就会抛出RejectedExecutionException异常。</p>
<blockquote>
<p>方式二：(更推荐)</p>
</blockquote>
<p>使用ThreadFactoryBuilder创建线程池</p>
<pre><code class="java">public class ExecutorsDemo &#123;
    private static ThreadFactory namedThreadFactory = new 
        ThreadFactoryBuilder().setNameFormat(&quot;demo-pool-%d&quot;).build();
    private static ExecutorService pool =
        new ThreadPoolExecutor(5, 200,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new 
                               ThreadPoolExecutor.
                               AbortPolicy());
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;
            pool.execute(new SubThread());
        &#125;
    &#125;
&#125;
</code></pre>
<p>这种方法不仅可以避免 OOM 的问题，还可以自定义线程名称，更加便于出错时溯源。</p>
<h1 id="四、谨慎使用ArrayList中的subList-方法"><a href="#四、谨慎使用ArrayList中的subList-方法" class="headerlink" title="四、谨慎使用ArrayList中的subList()方法"></a>四、谨慎使用ArrayList中的subList()方法</h1><h2 id="4-1-基础知识"><a href="#4-1-基础知识" class="headerlink" title="4.1 基础知识"></a>4.1 基础知识</h2><h3 id="4-1-1-subList-方法"><a href="#4-1-1-subList-方法" class="headerlink" title="4.1.1 subList()方法"></a>4.1.1 subList()方法</h3><p>subList() 是 List 接口中定义的一个方法，该方法主要用于返回一个集合中的一段，可以理解为截取一个集合中的部分元素，他的返回值也是一个 List。</p>
<p>如果将subList的返回值强转成ArrayList或其他List实现类，则会抛出ClassCastException异常。</p>
<h3 id="4-1-2-视图"><a href="#4-1-2-视图" class="headerlink" title="4.1.2 视图"></a>4.1.2 视图</h3><p>subList()方法返回的是一个视图，没有新建一个ArrayList，而是返回了一个ArrayList的内部类。这个内部类(SubList)即ArrayList的一个视图。</p>
<p>当通过set方法修改subList中某个元素的值的时候，源List中对应的元素的值也发生了改变；同理，对源List中的某个元素进行修改，那么subList中对应的值也会发生改变</p>
<h2 id="4-2-底层原理"><a href="#4-2-底层原理" class="headerlink" title="4.2 底层原理"></a>4.2 底层原理</h2><p>subList()的底层实现：</p>
<pre><code class="java">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, 0, fromIndex, toIndex);
&#125;
</code></pre>
<p>这个方法返回了一个SubList，这个类是ArrayList中的一个内部类</p>
<p>SubList中单独定义了set、get、size、add、remove方法。调用subList()方法时会调用SubList的构造器创建一个SubList：</p>
<pre><code class="java">SubList(AbstractList&lt;E&gt; parent,
        int offset, int fromIndex, int toIndex) &#123;
    this.parent = parent;
    this.parentOffset = fromIndex;
    this.offset = offset + fromIndex;
    this.size = toIndex - fromIndex;
    this.modCount = ArrayList.this.modCount;
&#125;
</code></pre>
<p>构造函数中把原来的 List 以及该 List 中的部分属性直接赋值给自己的一些属性。</p>
<p>==SubList只是ArrayList的内部类，没有继承关系，无法直接进行强制类型转换。==</p>
<h1 id="五、String字符串的“-”操作原理"><a href="#五、String字符串的“-”操作原理" class="headerlink" title="五、String字符串的“+”操作原理"></a>五、String字符串的“+”操作原理</h1><h2 id="5-1-基础知识"><a href="#5-1-基础知识" class="headerlink" title="5.1 基础知识"></a>5.1 基础知识</h2><h3 id="5-1-1-String的不可变性"><a href="#5-1-1-String的不可变性" class="headerlink" title="5.1.1 String的不可变性"></a>5.1.1 String的不可变性</h3><p>不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，比如可以缓存 hashcode、使用更加便利以及更加安全等。</p>
<h3 id="5-1-2-StringBuffer"><a href="#5-1-2-StringBuffer" class="headerlink" title="5.1.2 StringBuffer"></a>5.1.2 StringBuffer</h3><p>Java 中除了定义了一个可以用来定义字符串常量的 String 类以外，还提供了可以用来定义字符串变量的 StringBuffer 类，它的对象是可以扩充和修改的。</p>
<pre><code class="java">StringBuffer wechat = new StringBuffer(&quot;hanxj_a&quot;);
String introduce = &quot; intro &quot;;
StringBuffer res = wechat.append(&quot;,&quot;).append(introduce);
</code></pre>
<h3 id="5-1-3-StringBuilder"><a href="#5-1-3-StringBuilder" class="headerlink" title="5.1.3 StringBuilder"></a>5.1.3 StringBuilder</h3><p>除了 StringBuffer 以外，还有一个类 StringBuilder 也可以使用，其用法和 StringBuffer 类似。如：</p>
<pre><code class="java">StringBuilder wechat = new StringBuilder(&quot;hanxj_a&quot;);
String introduce = &quot; intro &quot;;
StringBuilder res = wechat.append(&quot;,&quot;).append(introduce);
</code></pre>
<h3 id="5-1-4-StringUtils-join"><a href="#5-1-4-StringUtils-join" class="headerlink" title="5.1.4 StringUtils.join()"></a>5.1.4 StringUtils.join()</h3><p>apache.commons 中提供的 StringUtils 类，其中的 join 方法可以拼接字符串。</p>
<pre><code class="java">String wechat = &quot;hanxj_a&quot;;
String introduce = &quot; intro &quot;;
System.out.println(StringUtils.join(wechat, &quot;,&quot;, introduce));
</code></pre>
<h2 id="5-2-‘-’的拼接原理"><a href="#5-2-‘-’的拼接原理" class="headerlink" title="5.2 ‘+’的拼接原理"></a>5.2 ‘+’的拼接原理</h2><p>反编译结果：</p>
<pre><code class="java">String wechat = &quot;hanxj_a&quot;;
String introduce = &quot; intro &quot;;
String hollis = (new StringBuilder()).append(wechat).append(&quot;,&quot;).
    append(introduce).toString();
</code></pre>
<p>字符串常量在拼接过程中，是将 String 转成了 StringBuilder 后，使用其 append 方法进行处理的。</p>
<p>从性能来看：StringBuilder&lt;StringBuffer&lt;concat&lt;+&lt;StringUtils.join</p>
<h1 id="六、foreach中remove-add引起的CME问题"><a href="#六、foreach中remove-add引起的CME问题" class="headerlink" title="六、foreach中remove/add引起的CME问题"></a>六、foreach中remove/add引起的CME问题</h1><h2 id="6-1-基础知识"><a href="#6-1-基础知识" class="headerlink" title="6.1 基础知识"></a>6.1 基础知识</h2><h3 id="6-1-1-foreach循环"><a href="#6-1-1-foreach循环" class="headerlink" title="6.1.1 foreach循环"></a>6.1.1 foreach循环</h3><p>也叫增强for</p>
<pre><code class="java">for( 元素类型 t 元素变量 x : 遍历对象 obj)&#123; 
    
&#125;
</code></pre>
<p>原理：</p>
<pre><code class="java">Iterator iterator = variable.iterator();
do
&#123;
    if(!iterator.hasNext())
        break;
    String variable = (String)iterator.next();
    // 引用了 x 的 java 语句 ; 
&#125; while(true);
</code></pre>
<h3 id="6-1-2-fail-fast机制"><a href="#6-1-2-fail-fast机制" class="headerlink" title="6.1.2 fail-fast机制"></a>6.1.2 fail-fast机制</h3><p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/3542">《fail-fast机制》</a></p>
<p>Java的集合类运用fail-fast机制进行设计，默认指的是Java集合的一种错误检测机制。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出CME。</p>
<p><strong>值得注意的是：</strong>很多时候代码并没有在多线程环境中执行，但依然会抛出CME。</p>
<ul>
<li>在Java中， 如果在foreach 循环里对某些集合元素进行元素的 remove/add 操作的时候，就会触发fail-fast机制</li>
</ul>
<h2 id="6-2-原理刨析"><a href="#6-2-原理刨析" class="headerlink" title="6.2 原理刨析"></a>6.2 原理刨析</h2><ul>
<li>modCount 是 ArrayList 中的一个成员变量。它表示该集合实际被修改的次数。</li>
<li>expectedModCount 是 ArrayList 中的一个内部类——Itr 中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator 方法被调用的时候初始化的。只有<strong>通过迭代器</strong>对集合进行操作，该值才会改变。</li>
<li>Itr 是一个 Iterator 的实现，使用 ArrayList.iterator 方法可以获取到的迭代器就是 Itr 类的实例</li>
</ul>
<h3 id="6-2-1-remove-add的工作机制"><a href="#6-2-1-remove-add的工作机制" class="headerlink" title="6.2.1 remove/add的工作机制"></a>6.2.1 remove/add的工作机制</h3><p>以remove为例</p>
<pre><code class="java">private void fastRemove(int index)&#123;
    modCount ++;
    int numMoved = size - index - 1;
    if(numMoved &gt; 0)
        System.arraycopy(elementData,index+1,elementData,index,numMoved);
    elementData[--size] = null; // clear to let GC do its work
&#125;
</code></pre>
<p>它只修改了 modCount，并没有对 expectedModCount 做任何操作</p>
<h3 id="6-2-2-原理分析"><a href="#6-2-2-原理分析" class="headerlink" title="6.2.2 原理分析"></a>6.2.2 原理分析</h3><p>通过异常堆栈可以发现，异常发生在<code>Iterator.next()</code>处，Iterator.next调用了<code>Iterator.checkForComodification()</code>方法。</p>
<pre><code class="java">final void checkForComodification() &#123;
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
&#125;
</code></pre>
<p>当<code>modCount != expectedModCount</code>就会抛出CME。</p>
<p>由6.2.1可以知道，modCount在自增，而expectedModCount没有操作，导致该语句被触发</p>
<h1 id="七、日志框架的使用"><a href="#七、日志框架的使用" class="headerlink" title="七、日志框架的使用"></a>七、日志框架的使用</h1><p>探究不能直接使用Log4j、Logback中API的原因</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220216212400766.png" alt="image-20220216212400766"></p>
<p>结论：为了解耦</p>
<p>建议：使用例如 Log4j + SLF4J的组合进行日志输出</p>
<h2 id="7-1-常用日志框架"><a href="#7-1-常用日志框架" class="headerlink" title="7.1 常用日志框架"></a>7.1 常用日志框架</h2><h3 id="7-1-1-j-u-l"><a href="#7-1-1-j-u-l" class="headerlink" title="7.1.1 j.u.l"></a>7.1.1 j.u.l</h3><p>j.u.l 是 JDK 1.4 引入的 java.util.logging 包的简称。Java Logging API 提供了七个日志级别用来控制输出。这七个级别分别是：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p>
<h3 id="7-1-2-Log4j"><a href="#7-1-2-Log4j" class="headerlink" title="7.1.2 Log4j"></a>7.1.2 Log4j</h3><ul>
<li>可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；</li>
<li>控制日志的输出格式</li>
<li>通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程</li>
<li>可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p>Log4j的七种日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG和 TRACE。</p>
<h3 id="7-1-3-LogBack"><a href="#7-1-3-LogBack" class="headerlink" title="7.1.3 LogBack"></a>7.1.3 LogBack</h3><p>logback 当前分成三个模块：logback-core,logback- classic 和 logback-access。logback-core 是其它两个模块的基础模块。logback-classic 是 Log4j 的一个改良版本。ogback-classic 完整实现 SLF4J API，可以很方便地更换成其它日记系统如 Log4j 或 j.u.l。logback-access 访问模块与Servlet 容器集成提供通过 Http 来访问日记的功能。</p>
<h3 id="7-1-4-Log4j2"><a href="#7-1-4-Log4j2" class="headerlink" title="7.1.4 Log4j2"></a>7.1.4 Log4j2</h3><p><em>与Log4j已经完全不同</em></p>
<h2 id="7-2-门面模式-外观模式"><a href="#7-2-门面模式-外观模式" class="headerlink" title="7.2 门面模式 (外观模式)"></a>7.2 门面模式 (外观模式)</h2><p>核心为：外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220216212512572.png" alt="image-20220216212512572" style="zoom:67%;" />





<h2 id="7-3-日志门面"><a href="#7-3-日志门面" class="headerlink" title="7.3 日志门面"></a>7.3 日志门面</h2><p>日志门面，是门面模式的一个典型的应用。是为了解决：“每一种日志框架都有自己单独的 API，要使用对应的框架就要使用其对应的 API，这就大大的增加应用程序代码对于日志框架的耦合性。” 这一问题，即<strong>解耦</strong></p>
<p>在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码。</p>
<h2 id="7-4-常用日志门面"><a href="#7-4-常用日志门面" class="headerlink" title="7.4 常用日志门面"></a>7.4 常用日志门面</h2><h3 id="7-4-1-SLF4J"><a href="#7-4-1-SLF4J" class="headerlink" title="7.4.1 SLF4J"></a>7.4.1 SLF4J</h3><p>Java 简易日志门面（Simple Logging Facade for Java，缩写 SLF4J），是一套包装 Logging 框架的界面程式，以外观模式实现。可以在软件部署的时候决定要使用的 Logging 框架，目前主要支持的有 Java Logging API、Log4j 及 logback等。</p>
<blockquote>
<p>Log4j 和 SLF4J对比</p>
</blockquote>
<ul>
<li>Log4j 提供 TRACE, DEBUG, INFO, WARN, ERROR 及 FATAL 六种纪录等级。SLF4J认为ERROR与FATAL没有本质区别，因此只有五种：TRACE, DEBUG, INFO, WARN, ERROR</li>
<li> logger.error(exception)操作中，Log4j会去把 exception.tostring。真正的写法应该是logger(message.exception); SLF4J中不会使得程序员书写不合适的写法。</li>
<li>Log4j 间接的在鼓励程序员使用 string 相加的写法(参考<a href="#%E4%BA%94%E3%80%81String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E2%80%9C+%E2%80%9D%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86">五、String字符串的“+”操作原理</a>,存在性能问题)，而 SLF4J 就不会有这个问题，可以使用 logger.error(“{} is+serviceid”,serviceid);</li>
<li> SLF4J 可以方便的使用其提供的各种集体的实现的 jar</li>
<li>提供字串内容替换的功能，会比较有效率</li>
<li>SLF4J 只支持 MDC，不支持 NDC</li>
</ul>
<h3 id="7-4-2-commons-logging"><a href="#7-4-2-commons-logging" class="headerlink" title="7.4.2 commons-logging"></a>7.4.2 commons-logging</h3><p>commons-logging 和 SLF4J 的功能是类似的。</p>
<p>是一个基于 Java 的日志记录实用程序，是用于日志记录和其他工具包的编程模型。它通过其他一些工具提供 API，日志实现和包装器实现。</p>
<h1 id="八、SimpleDateFormat不能被定义成static的原因"><a href="#八、SimpleDateFormat不能被定义成static的原因" class="headerlink" title="八、SimpleDateFormat不能被定义成static的原因"></a>八、SimpleDateFormat不能被定义成static的原因</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220216220634168.png" alt="image-20220216220634168"></p>
<h2 id="8-1-基础知识"><a href="#8-1-基础知识" class="headerlink" title="8.1 基础知识"></a>8.1 基础知识</h2><h3 id="8-1-1-SimpleDateFormat用法"><a href="#8-1-1-SimpleDateFormat用法" class="headerlink" title="8.1.1 SimpleDateFormat用法"></a>8.1.1 SimpleDateFormat用法</h3><p>用于 格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。使得可以选择任何用户定义的日期 - 时间格式的模式。</p>
<p>日期格式化时必须使用y表示年，而不能用Y，原因详见：<a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8y%E8%A1%A8%E7%A4%BA%E5%B9%B4%EF%BC%8C%E4%B8%8D%E7%94%A8Y%E7%9A%84%E5%8E%9F%E5%9B%A0">十二、日期格式化时必须使用y表示年，不用Y的原因</a> 。</p>
<p>使用 SimpleDateFormat 的 format 方法，将一个 Date 类型转化成 String 类型，并且可以指定输出格式：</p>
<pre><code class="java">//Date 转 String
Date date = new Date();
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String dateStr = sdf.format(date);
System.out.println(dateStr);
</code></pre>
<p>使用 SimpleDateFormat 的 parse 方法，将一个 String 类型转化成 Date 类型</p>
<pre><code class="java">//String 转 Date
System.out.println(sdf.parse(dateStr));
</code></pre>
<h3 id="8-1-2-日期和时间模式表达方法"><a href="#8-1-2-日期和时间模式表达方法" class="headerlink" title="8.1.2 日期和时间模式表达方法"></a>8.1.2 日期和时间模式表达方法</h3><p>使用 SimpleDateFormat 的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表如下：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220216215937576.png" alt="image-20220216215937576"></p>
<p>==模式字母通常是重复的，其数量确定其精确表示==</p>
<h3 id="8-1-3-输出不同时区的时间"><a href="#8-1-3-输出不同时区的时间" class="headerlink" title="8.1.3 输出不同时区的时间"></a>8.1.3 输出不同时区的时间</h3><p>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区。</p>
<p>使用SimpleDateFormat实现输出指定时区的时间：</p>
<pre><code class="java">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));
System.out.println(sdf.format(Calendar.getInstance().getTime()));
</code></pre>
<h3 id="8-1-4-参考资料"><a href="#8-1-4-参考资料" class="headerlink" title="8.1.4 参考资料"></a>8.1.4 参考资料</h3><p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/2888">《线程池的创建》</a></p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/290">《CountDownLatch详解》</a></p>
<h2 id="8-2-问题触发"><a href="#8-2-问题触发" class="headerlink" title="8.2 问题触发"></a>8.2 问题触发</h2><p>以下代码使用线程池执行时间输出：</p>
<pre><code class="java">public class Main&#123;
    /* 定义一个全局SimpleDateFormat */
    private static SimpleDateFormat simpleDateformat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    /* 使用ThreadFactoryBuilder定义一个线程池 */
    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat(&quot;demo-pool-%d&quot;)
        .build();
    private static ExecutorService pool = new ThreadPoolExecutor(5,200,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy() );
    
    /* 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行 */
    private static CountDownLatch countDownLatch = new CountDownLatch(100);
    
    public static void main(String[] args)&#123;
        // 定义一个线程安全的HashSet
        Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;());
        for(int i = 0; i &lt; 100; i ++)&#123;
            // 获取当前时间
            Calendar calendar = Calendar.getInstance();
            int finalI = i;
            pool.execute(()-&gt;&#123;
                // 时间增加
                calendar.add(Calendar.DATE, finalI);
                // 通过simpleDateFormat把时间转化成字符串
                String dateString = simpleDateFormat.format(calendar.getTime());
                // 把字符串放入Set中
                dates.add(dateString);
                // countDown
                countDownLatch.countDown();
                &#125;);
        &#125;
        // 阻塞,直到countDown数量为0
        countDownLatch.await();
        // 输出 去重后 的时间个数
        System.out.println(dates.size());
    &#125;
&#125;
//================================
// result &lt; 100
</code></pre>
<p>代码概述：循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的 Set 中，然后输出 Set 中元素个数。</p>
<p> SimpleDateFormat 作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，出现了线程安全问题。</p>
<h2 id="8-3-原理刨析"><a href="#8-3-原理刨析" class="headerlink" title="8.3 原理刨析"></a>8.3 原理刨析</h2><h3 id="8-3-1-线程不安全的原因"><a href="#8-3-1-线程不安全的原因" class="headerlink" title="8.3.1 线程不安全的原因"></a>8.3.1 线程不安全的原因</h3><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220216222924300.png" alt="image-20220216222924300"></p>
<p>SimpleDateFormat 中的 format 方法在执行过程中，会使用一个成员变量calendar 来保存时间。这就是问题的关键。</p>
<p>由于我们在声明 SimpleDateFormat 的时候，使用的是 static 定义的。那么这 个 SimpleDateFormat 就 是 一 个 共 享 变 量， 随 之，SimpleDateFormat 中 的calendar 也就可以被多个线程访问到。</p>
<p><em>假设线程 1 刚刚执行完 calendar.setTime 把时间设置成 2018-11-11，还没等执行完，线程 2 又执行了 calendar.setTime 把时间改成了 2018-12-12。这时候线程 1 继续往下执行，拿到的 calendar.getTime 得到的时间就是线程 2 改过之后的</em></p>
<p><strong>需要注意的是：</strong>除了 format 方法以外，SimpleDateFormat 的 parse 方法也有同样的问题</p>
<h3 id="8-3-2-解决方案"><a href="#8-3-2-解决方案" class="headerlink" title="8.3.2 解决方案"></a>8.3.2 解决方案</h3><ol>
<li><p>使用局部变量</p>
<pre><code class="java">for(int i = 0; i &lt; 100; i ++)&#123;
    // 获取当前时间
    Calendar calendar = Calendar.getInstance();
    int finalI = i;
    pool.execute(()-&gt;&#123;
       // SimpleDateFormat 声明为 局部变量
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        // 时间增加
        calendar.add(Calendar.DATE, finalI);
        // 通过simpleDateFormat把时间转换成字符串
        String dateString = simpleDateFormat.format(calendar.getTime());
        // 把字符串放入Set中
        dates.add(dateString);
        // countDown
        countDownLatch.countDown();
    &#125;);
&#125;
</code></pre>
</li>
<li><p>加同步锁</p>
<pre><code class="java">for (int i = 0; i &lt; 100; i++) &#123;
    // 获取当前时间
    Calendar calendar = Calendar.getInstance();
    int finalI = i;
    pool.execute(() -&gt; &#123;
        // 加锁
        synchronized (simpleDateFormat) &#123;
            // 时间增加
            calendar.add(Calendar.DATE, finalI);
            // 通过 simpleDateFormat 把时间转换成字符串
            String dateString = simpleDateFormat.format(calendar.getTime());
            // 把字符串放入 Set 中
            dates.add(dateString);
            //countDown
            countDownLatch.countDown();
        &#125;
    &#125;);
&#125;
</code></pre>
<p>优化：可以把锁的粒度再设置的小一点，可以只对 simpleDateFormat.format 这一行加锁</p>
</li>
<li><p>使用ThreadLocal</p>
<pre><code class="java">/* 使用Thread Local定义一个全局的simpleDateFormat */
private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;
    @Override
    protected SimpleDateFormat initialValue()&#123;
        return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;
&#125;;

// 使用
String dateString = simpleDateFormatThreadLocal
    .get()    // 得到全局的simpleDateFormat
    .format(calendar.getTime()); // 调用全局simpleDateFormat的format方法
</code></pre>
</li>
<li><p>使用DateTimeFormatter 代替SimpleDateFormat (JDK 8 +)</p>
<pre><code class="java">// 解析日期
String dateStr= &quot;2016 年 10 月 25 日 &quot;;
DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy 年 MM 月 dd 日 &quot;);
LocalDate date= LocalDate.parse(dateStr, formatter);
// 日期转换为字符串
LocalDateTime now = LocalDateTime.now();
DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy 年 MM 月 dd 日 hh:mm a&quot;);
String nowStr = now .format(format);

System.out.println(nowStr);
</code></pre>
</li>
</ol>
<h1 id="九、禁止使用isXxx作为变量名的原因"><a href="#九、禁止使用isXxx作为变量名的原因" class="headerlink" title="九、禁止使用isXxx作为变量名的原因"></a>九、禁止使用isXxx作为变量名的原因</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217150122710.png" alt="image-20220217150122710"></p>
<h2 id="9-1-使用场景"><a href="#9-1-使用场景" class="headerlink" title="9.1 使用场景"></a>9.1 使用场景</h2><p>关于这个”本次请求是否成功”的字段的定义，一般情况下，可以有以下四种方式来定义一个布尔类型的成员变量：</p>
<pre><code class="java">boolean success;
boolean isSuccess;
Boolean success;
Boolean isSuccess;
</code></pre>
<p>以上三种命名方式，在IDEA的POJO中自动构建的getter/setter 分别如下：</p>
<pre><code class="java">// 方式一：boolean success
class Model1 &#123;
    private boolean success;
    public boolean isSuccess()&#123;        // 相当于getter
        return success;
    &#125;
    public void setSuccess(boolean success)&#123;
        this.success = success;
    &#125;
&#125;
// 方式二：boolean isSuccess
class Model2 &#123;
    private boolean isSuccess;
    public boolean isSuccess() &#123;    // 相当于getter
        return isSuccess;
    &#125;
    public void setSuccess(boolean success)&#123;
        isSuccess = success;
    &#125;
&#125;
// 方式三：Boolean success
class Model3 &#123;
    private Boolean success;
    public Boolean getSuccess()&#123;
        return success;
    &#125;
    public void setSuccess(Boolean success)&#123;
        this.success = success;
    &#125;
&#125;
//方式四：Boolean isSuccess
class Model4 &#123;
    private Boolean isSuccess;
    public Boolean getSuccess()&#123;
        return isSuccess;
    &#125;
    public void setSuccess(Boolean success)&#123;
        isSuccess = success;
    &#125;
&#125;
</code></pre>
<p>简单来说：</p>
<ul>
<li>基本类型自动生成的 getter 和 setter 方法，名称都是 isXXX() 和 setXXX()形式的。</li>
<li>包 装 类 型 自 动 生 成 的 getter 和 setter 方 法， 名 称 都 是 getXXX() 和setXXX() 形式的。</li>
</ul>
<h2 id="9-2-原理剖析"><a href="#9-2-原理剖析" class="headerlink" title="9.2 原理剖析"></a>9.2 原理剖析</h2><h3 id="9-2-1-Java-Bean中关于setter-getter的规范"><a href="#9-2-1-Java-Bean中关于setter-getter的规范" class="headerlink" title="9.2.1 Java Bean中关于setter/getter的规范"></a>9.2.1 Java Bean中关于setter/getter的规范</h3><p>Java Bean 规范文档：<a target="_blank" rel="noopener" href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans(TM) Specification</a> 规定，如果是普通的参数 propertyName，要以以下方式定义其 setter/getter：</p>
<pre><code class="java">public &lt;PropertyType&gt; get&lt;PropertyName&gt;();
public void set&lt;PropertyName&gt;(&lt;PropertyType&gt; a);
</code></pre>
<p><strong>但是，布尔类型的变量 propertyName 则是单独定义的</strong>：</p>
<pre><code class="java">public boolean is&lt;PropertyName&gt;();
public void set&lt;PropertyName&gt;(boolean m);
</code></pre>
<p>因此根据Java Bean规范，Model2(boolean isSuccess)中变量名为isSuccess，如果严格按照规范定义，那么getter应命名为<code>isIsSuccess()</code>。但是多数IDE会默认生成<code>isSuccess</code></p>
<h3 id="9-2-2-序列化带来的影响"><a href="#9-2-2-序列化带来的影响" class="headerlink" title="9.2.2 序列化带来的影响"></a>9.2.2 序列化带来的影响</h3><p>这里以JSON序列化为例：</p>
<pre><code class="java">public class BooleanMainTest &#123;
    
    public static void main(String[] args) throws IOException &#123;
        // 创建Model2实体
        Model2 model2 = new Model2();
        model2.setSuccess(true);
        
        // 使用fastJson(1.2.16)序列化model2成字符串
        JSON.toJSONString(model2);
        
        // 使用Gson(2.8.5)序列化model2 成字符串
        gson.toJson(model2);
        
        //使用jackson(2.9.7)序列化model2成字符串
        ObjectMapper om = new ObjectMapper();
        om.writeValueAsString(model2);
    &#125;
&#125;

class Model2 implements Serializable &#123;
    private static final long serialVersionUID = 1836697963736227954L;
    private boolean isSuccess;
    public boolean isSuccess() &#123;
        return isSuccess;
    &#125;
    public void setSuccess(boolean success) &#123;
        isSuccess = success;
    &#125;
    public String getTest()&#123;
        return &quot;booleanTest&quot;;
    &#125;
&#125;
</code></pre>
<p>如果输出上述的三种序列化后的字符串：</p>
<pre><code class="java">Serializable Result With fastjson :&#123;&quot;test&quot;:&quot;booleanTest&quot;,&quot;success&quot;:true&#125;
Serializable Result With Gson :&#123;&quot;isSuccess&quot;:true&#125;
Serializable Result With jackson :&#123;&quot;success&quot;:true,&quot;test&quot;:&quot;booleanTest&quot;&#125;
</code></pre>
<p><strong>可以得出结论：</strong>fastjson 和 jackson 在把对象序列化成 json 字符串的时候，是通过反射遍历出该类中的<strong>所有 getter 方法</strong>，得到getTest和isSuccess，然后根据JavaBeans规则，认为这是两个属性test和success的值。直接序列化成json:{“test”:”booleanTest”,”success”:true}。 Gson通过反射遍历该类中的<strong>所有属性</strong>，并把其值序列化成 json:{“isSuccess”:true}。</p>
<p>若不考虑getTest，那么结果应该是：</p>
<pre><code class="java">Serializable Result With fastjson :&#123;&quot;success&quot;:true&#125;
Serializable Result With Gson :&#123;&quot;isSuccess&quot;:true&#125;
Serializable Result With jackson :&#123;&quot;success&quot;:true&#125;
</code></pre>
<p>不同的序列化框架得到的 json 内容并不相同，如果使用 fastjson 进行序列化，再使用 Gson 反序列化：</p>
<pre><code class="java">public class BooleanMainTest &#123;
    public static void main(String[] args) throws IOException &#123;
        Model2 model2 = new Model2();
        Model2.setSuccess(true);
        Gson gson = new Gson();
        System.out.println( gson.fromJson( JSON.toJSONString(model2), Model2.class ) );
    &#125;
&#125;
class Model2 implements Serializable &#123;
    private static final long serialVersionUID = 1836697963736227954L;
    private boolean isSuccess;
    public boolean isSuccess() &#123;
        return isSuccess;
    &#125;
    public void setSuccess(boolean success) &#123;
        isSuccess = success;
    &#125;
    @Override
    public String toString() &#123;
        return new StringJoiner(&quot;, &quot;, Model2.class.getSimpleName() + &quot;[&quot;,&quot;]&quot;)
            .add(&quot;isSuccess=&quot; + isSuccess)
            .toString();
    &#125;
&#125;
// ================================
// Model2[isSuccess=false]
</code></pre>
<p>我们setSuccces为true，而最终得到的结果是false，这是因为：</p>
<p>JSON 框架通过扫描所有的 getter后发现有一个 isSuccess 方法，然后根据 JavaBeans 的规范，解析出变量名为success，把 model 对象序列化城字符串后内容为<code> &#123;&quot;success&quot;:true&#125;</code></p>
<p>根据 {“success”:true} 这个 json 串，Gson 框架在通过解析后，通过反射寻找 Model 类中的 success 属性，但是 Model 类中只有 isSuccess 属性，所以，最终反序列化后的 Model 类的对象中，isSuccess 则会使用默认值 false。</p>
<h3 id="9-2-3-在POJO中Boolean和boolean的使用"><a href="#9-2-3-在POJO中Boolean和boolean的使用" class="headerlink" title="9.2.3 在POJO中Boolean和boolean的使用"></a>9.2.3 在POJO中Boolean和boolean的使用</h3><p>经过 &lt;&lt;9.2.2 序列化带来的影响&gt;&gt; 的解释，排除错误项后，还剩：</p>
<pre><code class="java">boolean success;
Boolean success;
</code></pre>
<p>结论：定义一个成员变量时，使用包装类型更好。</p>
<pre><code class="java">public class BooleanMainTest &#123;
    public static void main(String[] args) &#123;
        Model model = new Model();
        System.out.println(&quot;default model: &quot; + model);
    &#125;
&#125;
class Model &#123;
    private Boolean success;
    private boolean failure;
    @Override
    public String toString()&#123;
        return new StringJoiner(&quot;, &quot; , Model.class.getSimpleName() + &quot;[&quot;, &quot;]&quot;)
            .add(&quot;success=&quot; + success)
            .add(&quot;failure=&quot; + failure)
            .toString();
    &#125;
&#125;
// =============================================
// default model : Model[success=null, failure=false]
</code></pre>
<p>当我们没有设置 Model 对象的字段的值的时候，Boolean 类型的变量会设置默认值为 null，而 boolean 类型的变量会设置默认值为 false。（即对象的默认值是 null，boolean 基本数据类型的默认值是 false）</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217160819331.png" alt="image-20220217160819331"></p>
<blockquote>
<p>举例</p>
</blockquote>
<p>扣费系统：扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值得时候就使用公式：金额 * 费率 = 费用 进行计算，计算结果进行划扣。</p>
<p>如果由于计费系统异常，他可能会返回个默认值，如果这个字段是 Double 类型的话，该默认值为 null，如果该字段是 double 类型的话，该默认值为 0.0。</p>
<p>如果扣费系统对于该费率返回值没做特殊处理的话，拿到 null 值进行计算会直接报错，阻断程序。拿到 0.0 可能就直接进行计算，得出接口为 0 后进行扣费了。</p>
<p>如果是基本类型，这种异常情况就无法被感知！！</p>
<h2 id="9-3-拓展：由JavaBean规范引起的异常"><a href="#9-3-拓展：由JavaBean规范引起的异常" class="headerlink" title="9.3 拓展：由JavaBean规范引起的异常"></a>9.3 拓展：由JavaBean规范引起的异常</h2><p>JavaBean的规范中明确提到：如果第一个字母是小写，第二个字母大写的情况(如：eId, eName…)，在生成setter/getter的时候直接在前面加上set/get，比如eId的setter/getter是seteId()/geteId()，所以 eId在注入的时候会寻找seteId()方法，而不是setEId()。</p>
<p>但是Lombok等插件自动生成的get/set是setEId()和getEId()，因此注入时会找不到seteId()方法</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>在属性上面加注解@JsonProperty(value = “eId”)</li>
<li>不使用lombok, 手动写setter -&gt; seteId()</li>
</ol>
<h1 id="十、禁止修改serialVersionUID值的原因"><a href="#十、禁止修改serialVersionUID值的原因" class="headerlink" title="十、禁止修改serialVersionUID值的原因"></a>十、禁止修改serialVersionUID值的原因</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217161611775.png" alt="image-20220217161611775"></p>
<h2 id="10-1-基础知识"><a href="#10-1-基础知识" class="headerlink" title="10.1 基础知识"></a>10.1 基础知识</h2><p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/1150">《序列化与反序列化》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/1140">《深入分析Java序列化与反序列化》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/1144">《单例与序列化》</a></li>
</ul>
<h3 id="10-1-1-Serializable"><a href="#10-1-1-Serializable" class="headerlink" title="10.1.1 Serializable"></a>10.1.1 Serializable</h3><p>类通过实现 java.io.Serializable 接口以启用其序列化功能。<strong>未实现此接口的类将无法进行序列化或反序列化。</strong></p>
<p> <strong>Serializable 接口没有方法或字段，仅用于标识可序列化的语义。</strong>但是，如果一个类没有实现这个接口，想要被序列化的话，就会抛出 java.io.NotSerializableException 异常：</p>
<pre><code class="java">// 在执行序列化时会执行：
if (obj instanceof String) &#123;
    writeString((String) obj, unshared);
&#125; else if (c1.isArray())&#123;
    writeArray(obj, desc, unshared);
&#125; else if (obj instanceof Enum)&#123;
    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
&#125; else if (obj instanceof Serializable)&#123;
    writeOrdinaryObject(obj, desc, unshared);
&#125; else &#123;
    if (extendedDebugInfo) &#123;
        throw new NotSerializableException(c1.getName() + &quot;\n&quot; + debugInfoStack.toString());
    &#125;else &#123;
        throw new NotSerializableException(c1.getName());
    &#125;
&#125;
</code></pre>
<p>在进行序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果都不是则直接抛出 NotSerializableException。</p>
<h3 id="10-1-2-Externalizable"><a href="#10-1-2-Externalizable" class="headerlink" title="10.1.2 Externalizable"></a>10.1.2 Externalizable</h3><p>Externalizable 继承自 Serializable，该接口中定义了两个抽象方法：<code>writeExternal()</code> 与<code> readExternal()</code></p>
<p>当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重写 writeExternal() 与 readExternal() 方法。否则所有变量的值都会变成默认值。</p>
<h3 id="10-1-3-transient"><a href="#10-1-3-transient" class="headerlink" title="10.1.3 transient"></a>10.1.3 transient</h3><p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以<strong>阻止该变量被序列化到文件中</strong>，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h3 id="10-1-4-自定义序列化策略"><a href="#10-1-4-自定义序列化策略" class="headerlink" title="10.1.4 自定义序列化策略"></a>10.1.4 自定义序列化策略</h3><p>​    在序列化过程中，如果被序列化的类中定义了<code>writeObject </code>和<code>readObject</code>方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。</p>
<p>​    如果没有这样的方法，则默认调用是 <code>ObjectOutputStream 的 defaultWriteObject </code>方法以及 <code>ObjectInputStream 的 defaultReadObject </code>方法。</p>
<p>​    用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用 transient 修饰，并自己重写 writeObject 和 readObject 方法。(ArrayList中就有这样的实现)</p>
<h3 id="10-1-5-serialVersionUID"><a href="#10-1-5-serialVersionUID" class="headerlink" title="10.1.5 serialVersionUID"></a>10.1.5 serialVersionUID</h3><p>==序列化是将对象的状态信息转换为可存储或传输的形式的过程。== 可以在JVM 停机的情况下也能把对象保存下来。</p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化 ID，就是我们在代码中定义的 <code>serialVersionUID</code>。</p>
<blockquote>
<p>举例：serialVersionUID变化后会发生什么</p>
</blockquote>
<pre><code class="java">public class SerializableDemo &#123;
    public static void main(String[] args) &#123;
        // 初始化Object
        User1 user = new User1();
        user.setName(&quot;Han Xiaojie&quot;);
        // 序列化到文件
        ObjectOutputStream oos = null;
        try &#123;
            oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));
            oos.writeObject(user);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            IOUtils.closeQuietly(oos);
        &#125;
    &#125;
&#125;
class User1 implements Serializable &#123;
    private static final long serialVersionUID = 1L;
    private String name;
    
    public String getName() &#123;return name;&#125;
    public void setName(String name) &#123;this.name = name;&#125;
&#125;
</code></pre>
<p>存入文件后，修改User1类，将serialVersionUID修改为2L</p>
<pre><code class="java">class User1 implements Serializable &#123;
    private static final long serialVersionUID = 2L;
    private String name;
    
    public String getName() &#123;return name;&#125;
    public void setName(String name) &#123; this.name = name;&#125;
&#125;
</code></pre>
<p>反序列化</p>
<pre><code class="java">public class SerializableDemo2 &#123;
    public static void main(String[] args) &#123;
        // 从File中读数据
        File file = new File(&quot;tempFile&quot;);
        ObjectInputStream ois = null;
        try &#123;
            ois = new ObjectInputStream(new FileInputStream(file));
            User1 newUser = (User1) ios.readObject();
            System.out.println(newUser);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            IOUtils.closeQuietly(ois);
            try &#123;
                FileUtils.forceDelete(file);
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>执行结果：</p>
<pre><code class="java">java.io.InvalidClassException: com.hollis.User1; local class incompatible: stream classdesc 
serialVersionUID = 1, local class serialVersionUID = 2
</code></pre>
<blockquote>
<p>举例：不设置serialVersionUID</p>
</blockquote>
<p>根据上各例子的demo代码，修改User1：</p>
<pre><code class="java">class User1 implements Serializable &#123;
    private String name;
    
    public String getName() &#123;return name;&#125;
    public void setName(String name) &#123;this.name = name;&#125;
&#125;
</code></pre>
<p>然后修改User1类，向其中增加一个属性：</p>
<pre><code class="java">class User1 implements Serializable &#123;
    private String name;
    private int age;
    
    public String getName() &#123;return name;&#125;
    public void setName(String name) &#123;this.name = name;&#125;
    public int getAge() &#123;return age;&#125;
    public void setAge(int age) &#123;this.age = age;&#125;
&#125;
</code></pre>
<p>反序列化结果：</p>
<pre><code class="java">java.io.InvalidClassException: com.hollis.User1; 
local class incompatible: stream classdesc serialVersionUID = -2986778152837257883, local class serialVersionUID = 7961728318907695402
</code></pre>
<p>从本例中可以看出，系统自己添加了一个serialVersionUID。</p>
<p>serialVersionUID的两种显式生成方式：</p>
<ul>
<li>默认的 1L，比如：private static final long serialVersionUID = 1L;</li>
<li>根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段，如：private static final long serialVersionUID = xxxxL; ([本方法可以借助IDE实现](#10.3 IDEA提示设置))</li>
</ul>
<p>==总结来说，serialVersionUID 其实是验证版本一致性的==</p>
<h2 id="10-2-原理剖析"><a href="#10-2-原理剖析" class="headerlink" title="10.2 原理剖析"></a>10.2 原理剖析</h2><p>反序列化的调用链：</p>
<p><code>ObjectInputStream.readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; readClassDesc -&gt; readNonProxyDesc -&gt; ObjectStreamClass.initNonProxy</code></p>
<p>在<code>initNonProxy</code>中，关键代码：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217164748622.png" alt="image-20220217164748622"></p>
<p>在反序列化过程中，对 serialVersionUID 做了比较，如果发现不相等，则直接抛出异常</p>
<p>深入至 getSerialVersionUID() 方法：</p>
<pre><code class="java">public long getSerialVersionUID() &#123;
    // REMIND: synchronize instead of relying on volatile?
    if (suid == null) &#123;
        suid = AccessController.doPrivileged(
            new PrivilegeAction&lt;Long&gt;() &#123;
                public Long run() &#123;
                    return computeDefaultSUID(c1);
                &#125;
            &#125;
        );
    &#125;
    return suid.longValue();
&#125;
</code></pre>
<p>在没有定义 serialVersionUID 的时候，会调用 computeDefaultSUID 方法，生成一个默认的 serialVersionUID。</p>
<p>这里也解释了  [&lt;&lt;10.1.5 serialVersionUID&gt;&gt;](#10.1.5 serialVersionUID) 中两个例子的现象</p>
<h2 id="10-3-IDEA的提示设置"><a href="#10-3-IDEA的提示设置" class="headerlink" title="10.3 IDEA的提示设置"></a>10.3 IDEA的提示设置</h2><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217165356925.png" alt="image-20220217165356925"></p>
<ol>
<li>File -&gt; setting 中搜索serialVersionUID</li>
<li>勾选<code>Serializable class without serialVersionUID</code>项。</li>
</ol>
<h1 id="十一、禁止使用Apache-Beanutils进行属性copy的原因"><a href="#十一、禁止使用Apache-Beanutils进行属性copy的原因" class="headerlink" title="十一、禁止使用Apache Beanutils进行属性copy的原因"></a>十一、禁止使用Apache Beanutils进行属性copy的原因</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217172413260.png" alt="image-20220217172413260"></p>
<h2 id="11-1-常用工具类"><a href="#11-1-常用工具类" class="headerlink" title="11.1 常用工具类"></a>11.1 常用工具类</h2><ul>
<li>Spring BeanUtils</li>
<li>Cglib BeanCopier</li>
<li>Apache BeanUtils</li>
<li>Apache PropertyUtils</li>
<li>Dozer</li>
</ul>
<h2 id="11-2-性能对比"><a href="#11-2-性能对比" class="headerlink" title="11.2 性能对比"></a>11.2 性能对比</h2><p>POJO：</p>
<pre><code class="java">public class PersonDO &#123;
    private Integer id;
    private String name;
    private Integer age;
    private Date birthday;
    // 省略 setter/getter
&#125;
// ===================================
public class PersonDTO &#123;
    private String name;
    private Integer age;
    private Date birthday;
&#125;
</code></pre>
<blockquote>
<p>使用Spring BeanUtils进行属性拷贝</p>
</blockquote>
<pre><code class="java">private void mappingBySpringBeanUtils(PersonDO personDO, int times) &#123;
    // stopwatch 用于记录代码执行时间
    StopWatch stopwatch = new StopWatch();
    stopwatch.start();
    
    for(int i = 0; i &lt; times; i++) &#123;
        PersonDTO personDTO = new PersonDTO();
        org.springframework.beans.BeanUtils.copyProperties(personDO, personDTO);
    &#125;
    stopwatch.stop();
    System.out.println(&quot;mappingBySpringBeanUtils cost :&quot; + stopwatch.getTotalTimeMillis());
&#125;
</code></pre>
<blockquote>
<p>使用Cglib BeanCopier进行属性拷贝</p>
</blockquote>
<pre><code class="java">private void mappingByCglibBeanCopier (PersonDO personDO, int time) &#123;
    StopWatch stopwatch = new StopWatch();
    stopwatch.start();
    
    for(int i = 0; i &lt; times; i++)&#123;
        PersonDTO personDTO = new PersonDTO();
        BeanCopier copier = BeanCopier.create(PersonDO.class, PersonDTO.class, false);
        copier.copy(personDO, personDTO, null);
    &#125;
    stopwatch.stop();
    System.out.println(&quot;mappingByCglibBeanCopier cost :&quot; + stopwatch.getTotalTimeMillis());
&#125;
</code></pre>
<blockquote>
<p>使用Apache BeanUtils进行属性拷贝</p>
</blockquote>
<pre><code class="java">private void mappingByApachePropertyUtils(PersonDO personDO, int times) throws InvocationTargetException, IllegalAccessException,NoSuchMethodException &#123;
    StopWatch stopwatch = new StopWatch();
    stopwatch.start();
    for(int i = 0; i &lt; times; i++)&#123;
        PersonDTO personDTO = new PersonDTO();
        BeanUtils.copyProperties(personDTO, personDO);
    &#125;
    stopwatch.stop();
    System.out.println(&quot;mappingByApacheBeanUtils cost :&quot; + stopwatch.getTotalTimeMillis());
&#125;
</code></pre>
<blockquote>
<p>使用Apache PropertyUtils进行属性拷贝</p>
</blockquote>
<pre><code class="java">private void mappingByApachePropertyUtils(PersonDO personDO, int times) throws nvocationTargetException, IllegalAccessException,NoSuchMethodException &#123;
    StopWatch stopwatch = new StopWatch();
    stopwatch.start();
    for(int i = 0; i &lt; times; i++)&#123;
        PersonDTO personDTO = new PersonDTO();
        PropertyUtils.copyProperties(personDTO, personDO);
    &#125;
    stopwatch.stop();
    System.out.println(&quot;mappingByApachePropertyUtils cost :&quot; + stopwatch.getTotalTimeMillis());
&#125;
</code></pre>
<p>性能测试代码：</p>
<pre><code class="java">public static void main(String[] args)
    throws InvocationTargetException, IllegalAccessException, 
NoSuchMethodException &#123;
    PersonDO personDO = new PersonDO();
    personDO.setName(&quot;Hollis&quot;);
    personDO.setAge(26);
    personDO.setBirthday(new Date());
    personDO.setId(1);
    MapperTest mapperTest = new MapperTest();
    mapperTest.mappingBySpringBeanUtils(personDO, 100);
    mapperTest.mappingBySpringBeanUtils(personDO, 1000);
    mapperTest.mappingBySpringBeanUtils(personDO, 10000);
    mapperTest.mappingBySpringBeanUtils(personDO, 100000);
    mapperTest.mappingBySpringBeanUtils(personDO, 1000000);
    mapperTest.mappingByCglibBeanCopier(personDO, 100);
    mapperTest.mappingByCglibBeanCopier(personDO, 1000);
    mapperTest.mappingByCglibBeanCopier(personDO, 10000);
    mapperTest.mappingByCglibBeanCopier(personDO, 100000);
    mapperTest.mappingByCglibBeanCopier(personDO, 1000000);
    mapperTest.mappingByApachePropertyUtils(personDO, 100);
    mapperTest.mappingByApachePropertyUtils(personDO, 1000);
    mapperTest.mappingByApachePropertyUtils(personDO, 10000);
    mapperTest.mappingByApachePropertyUtils(personDO, 100000);
    mapperTest.mappingByApachePropertyUtils(personDO, 1000000);
    mapperTest.mappingByApacheBeanUtils(personDO, 100);
    mapperTest.mappingByApacheBeanUtils(personDO, 1000);
    mapperTest.mappingByApacheBeanUtils(personDO, 10000);
    mapperTest.mappingByApacheBeanUtils(personDO, 100000);
    mapperTest.mappingByApacheBeanUtils(personDO, 1000000);
&#125;
</code></pre>
<p>运行结果：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217222754740.png" alt="image-20220217222754740"></p>
<p>折线图：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217222810438.png" alt="image-20220217222810438"></p>
<p>在性能方面，Spring BeanUtils 和 Cglib BeanCopier 表现比较不错，</p>
<p>Apache PropertyUtils、Apache BeanUtils 以及 Dozer则表现的很不好</p>
<p>​        所以考虑性能的话，不要选择 Apache PropertyUtils、Apache BeanUtils 以及 Dozer 等工具类。Apache BeanUtils 力求做得完美 , 在代码中增加了非常多的校验、兼容、日志打印等代码，过度的包装导致性能下降严重。</p>
<h1 id="十二、日期格式化时必须使用y表示年，不用Y的原因"><a href="#十二、日期格式化时必须使用y表示年，不用Y的原因" class="headerlink" title="十二、日期格式化时必须使用y表示年，不用Y的原因"></a>十二、日期格式化时必须使用y表示年，不用Y的原因</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217224239863.png" alt="image-20220217224239863"></p>
<p>SimpleDateFormat的用法可见：[8.1.1 SimpleDateFormat用法](#8.1.1 SimpleDateFormat用法)</p>
<h2 id="12-1-ISO-8601"><a href="#12-1-ISO-8601" class="headerlink" title="12.1 ISO 8601"></a>12.1 ISO 8601</h2><p>因为不同人对于日期和时间的表示方法有不同的理解，于是制定了一个国际规范：ISO 8601。</p>
<p>​        国际标准化组织的国际标准 ISO 8601 是<strong>日期和时间的表示方法</strong>，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》</p>
<p>在 ISO 8601 中。对于一年的第一个日历星期有以下四种等效说法：</p>
<ol>
<li>本年度第一个星期四所在的星期</li>
<li>1 月 4 日所在的星期</li>
<li>本年度第一个至少有 4 天在同一星期内的星期</li>
<li>星期一在去年 12 月 29 日至今年 1 月 4 日以内的星期</li>
</ol>
<p>根据这个标准，我们可以推算出：</p>
<p>2020 年第一周：2019.12.29-2020.1.4</p>
<p>所以， 根 据 ISO 8601 标 准，2019 年 12 月 29 日、2019 年 12 月 30 日、2019 年 12 月 31 日这两天，其实不属于 2019 年的最后一周，而是属于 2020 年的第一周</p>
<h2 id="12-2-JDK-针对ISO-8601提供的支持"><a href="#12-2-JDK-针对ISO-8601提供的支持" class="headerlink" title="12.2 JDK 针对ISO 8601提供的支持"></a>12.2 JDK 针对ISO 8601提供的支持</h2><p>​        我们希望输入一个日期，然后程序告诉我们，根据 ISO 8601 中关于日历日期的定义，这个日期到底属于哪一年。比如输入 2019-12-20，他显示 2019；而输入 2019-12-30 的时候，他显示 2020。</p>
<p>​        为了提供这样的数据，Java 7 引入了「YYYY」作为一个新的日期模式来作为标识。使用「YYYY」作为标识，再通过 SimpleDateFormat 就可以得到一个日期所属的周属于哪一年了。</p>
<pre><code class="java">public class WeekYearTest &#123;
    public static void main(String[] args) &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;YYYY&quot;);
        System.out.println(sdf1.format(sdf.parse(&quot;2019-12-01&quot;)));
        System.out.println(sdf1.format(sdf.parse(&quot;2019-12-30&quot;)));
        System.out.println(sdf1.format(sdf.parse(&quot;2020-01-01&quot;)));
    &#125;
&#125;
// =============================
// 2019
// 2020
// 2020
</code></pre>
<p>因为有这样的情况，所以在日常开发的时候，如果把 y 写成了 Y，那就可能导致日期输出的结果不符合我们的预期。</p>
<p>当我们要表示日期的时候，==一定要使用 yyyy-MM-dd 而不是 YYYY-MM-dd==，这两者的返回结果大多数情况下都一样，但是极端情况就会有问题了。</p>
<h1 id="十三、MySQL中count-列名-、count-常量-和count-的区别"><a href="#十三、MySQL中count-列名-、count-常量-和count-的区别" class="headerlink" title="十三、MySQL中count(列名)、count(常量)和count(*)的区别"></a>十三、MySQL中count(列名)、count(常量)和count(*)的区别</h1><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220217170145676.png" alt="image-20220217170145676"></p>
<h2 id="13-1-COUNT"><a href="#13-1-COUNT" class="headerlink" title="13.1 COUNT"></a>13.1 COUNT</h2><ol>
<li>COUNT(expr) ，返回 SELECT 语句检索的行中 expr 的值不为 NULL 的数量。结果是一个 BIGINT 值。</li>
<li>如果查询结果没有命中任何记录，则返回 0。</li>
<li><strong>值得注意的是</strong>，COUNT(*) 的统计结果中，会包含值为 NULL 的行数。</li>
</ol>
<h2 id="13-2-count-列名-、count-常量-和count-之间的区别"><a href="#13-2-count-列名-、count-常量-和count-之间的区别" class="headerlink" title="13.2 count(列名)、count(常量)和count(*)之间的区别"></a>13.2 count(列名)、count(常量)和count(*)之间的区别</h2><p>列名、常量 和 * 这三个条件中，</p>
<p><code>常量</code> 是一个固定值，肯定不为 NULL，</p>
<p><code>*</code> 可以理解为查询整行，所以肯定也不为 NULL，</p>
<p><code>列名</code> 可能为NULL</p>
<p>所以， <strong>COUNT( 常量 ) 和 COUNT(*) 表示的是直接查询符合条件的数据库表的行数</strong>。而 <strong>COUNT( 列名 ) 表示的是查询符合条件的列的值不为 NULL 的行数</strong>。</p>
<h2 id="13-3-COUNT-优化"><a href="#13-3-COUNT-优化" class="headerlink" title="13.3 COUNT(*) 优化"></a>13.3 COUNT(*) 优化</h2><p>​    优化与SQL引擎有关，MySQL中常用InnoDB和MyISAM。COUNT(*)的优化主要和“MyISAM 不支持事务，MyISAM 中的锁是表级锁；而InnoDB 支持事务，并且支持行级锁。”有关</p>
<p>​    因为 MyISAM 的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，MyISAM 做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用 COUNT(*) 进行查询的时候，可以直接返回这个记录下来的数值就可以了，但前提是不能有 where 条件。</p>
<p><em>MyISAM 数据库是表级锁，不会有并发的数据库行数修改，查询得到的行数是准确的。</em></p>
<p>​    在 InnoDB 中，使用COUNT(*)要不可避免的扫表，在扫表的过程中做了一些优化：MySQL 会优先选择<strong>最小的非聚簇索引</strong>来扫表。所以，当我们建表的时候，除了主键索引以外，<strong>创建一个非主键索引还是有必要的</strong>。</p>
<p><em>InnoDB中的优化前提是查询语句中不包含WHERE或GROUP BY等条件</em></p>
<h2 id="13-4-COUNT-和COUNT-1"><a href="#13-4-COUNT-和COUNT-1" class="headerlink" title="13.4 COUNT(*) 和COUNT(1)"></a>13.4 COUNT(*) 和COUNT(1)</h2><p>==对于 COUNT(1)和 COUNT(*)，MySQL 的优化是完全一样的!!==</p>
<p>但是更建议使用COUNT(*)</p>
<p>COUNT(*)是 SQL92 定义的标准统计行数的语法</p>
<h2 id="13-5-COUNT-字段"><a href="#13-5-COUNT-字段" class="headerlink" title="13.5 COUNT( 字段 )"></a>13.5 COUNT( 字段 )</h2><p>工作原理：全表扫描，然后判断指定字段的值是不是为 NULL，不为 NULL 则累加。</p>
<p>相比 COUNT( * )，COUNT( 字段 ) 多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比 COUNT( * ) 慢。</p>
<h2 id="13-6-总结"><a href="#13-6-总结" class="headerlink" title="13.6 总结"></a>13.6 总结</h2><p><strong>结论：建议使用COUNT(*)</strong></p>
<p>​    因为 COUNT(*) 是 SQL92 定义的标准统计行数的语法，所以 MySQL 对他进行了很多优化</p>
<p>​    在 InnoDB 中 COUNT(*) 和 COUNT(1) 实现上没有区别，而且效率一样，但是COUNT( 字段 ) 需要进行字段的非 NULL 判断，所以效率会低一些。</p>
<h1 id="十四、Java值传递的误区和探索"><a href="#十四、Java值传递的误区和探索" class="headerlink" title="十四、Java值传递的误区和探索"></a>十四、Java值传递的误区和探索</h1><p>==首先讲结论：Java只有值传递，没有引用传递==</p>
<p><em>声明：三个误区均为错误结论。本章就是要解释三个误区为什么错，错在哪里</em></p>
<ul>
<li>误区一：值传递和和引用传递，区分的条件是传递的内容，如果是个值，就是值传递；如果是个引用就是引用传递。</li>
<li>误区二：Java存在引用传递。</li>
<li>误区三：传递的参数如果是普通类型，那就是值传递；如果是对象，那就是引用传递。</li>
</ul>
<h2 id="14-1-值传递和引用传递"><a href="#14-1-值传递和引用传递" class="headerlink" title="14.1 值传递和引用传递"></a>14.1 值传递和引用传递</h2><p>当我们调用一个有参函数的时候，会把实际参数(实参)传递给形式参数(形参)。但是，在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。定义如下：</p>
<ul>
<li>值传递(pass by value)：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递(pass by reference)：指在调用函数时将实际参数的<strong>地址</strong>直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ul>
<p>值传递和引用传递的根本区别是：<strong>值传递会创建副本，引用传递不创建副本</strong></p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        int i = 10;
        pass(i);
        System.out.println(&quot;In Main,i is &quot; + i);
    &#125;
    static void pass(int j) &#123;
        j = 20;
        System.out.println(&quot;In Pass,j is &quot; + j);
    &#125;
&#125;
// ========================OUTPUT=============================
// In Pass,j is 20
// In Main,i is 10
</code></pre>
<p>由上述实例，我们可以看出，当形参为基本类型时，Java的方法是值传递。</p>
<p>(本实例仅展示值传递和引用传递的区别，不能因当前实例妄下结论：Java的方法均是值传递。但在下文会去证实这个结论)</p>
<h2 id="14-2-问题复现"><a href="#14-2-问题复现" class="headerlink" title="14.2 问题复现"></a>14.2 问题复现</h2><p>实例：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        User han = new User();
        han.setName(&quot;Han Xiaojie&quot;);
        han.setAge(22);
        pass(han);
        System.out.println(&quot;In Main,user is &quot; + user);
    &#125;

    static void pass(User user) &#123;
        user.setName(&quot;SkyFroop&quot;);
        System.out.println(&quot;In Pass,user is &quot; + user);
    &#125;
&#125;

class User &#123;
    private String name;
    private Integer age;
    /* 省略Setter/Getter和toString() */
&#125;
// ========================OUTPUT=============================
// In Pass,user is User&#123;name=&#39;SkyFroop&#39;, age=22&#125;
// In Main,user is User&#123;name=&#39;SkyFroop&#39;, age=22&#125;
</code></pre>
<p>为什么这里的实参发生变化了？</p>
<p>那是不是可以得出 “传递的参数如果是普通类型，那就是值传递；如果是对象，那就是引用传递”的结论呢？</p>
<p>再看下面的例子：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        String name = &quot;Han Xiaojie&quot;
        pass(user);
        System.out.println(&quot;In Main,name is &quot; + user);
    &#125;

    static void pass(User name) &#123;
        name = &quot;SkyFroop&quot;
        System.out.println(&quot;In Pass,name is &quot; + user);
    &#125;
&#125;
// ========================OUTPUT=============================
// In Pass,name is SkyFroop
// In Main,name is Han Xiaojie
</code></pre>
<p>同样传递了一个对象，但是原始参数的值并没有被修改。</p>
<h2 id="14-3-Java的值传递"><a href="#14-3-Java的值传递" class="headerlink" title="14.3 Java的值传递"></a>14.3 Java的值传递</h2><p>上面，我们举了三个例子，表现的结果却不一样，上面的概念没有错，只是代码展示了三种值传递的情况。</p>
<p>回到14.2的第一个例子，从JMM层面来看：</p>
<img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220315202311356.png" alt="image-20220315202311356" style="zoom:80%;" />

<p>在参数传递过程中，实际参数的地址0x123456 <strong>拷贝</strong>给了形参user，只是，在这个方法中，并没有对形参本身进行修改，而是修改的形参持有的地址中存储的内容。也就是修改的并不是0x123456这个值，而是修改的这个引用下的成员变量的引用。因此这里仍然是值传递，只不过这个值，是一个地址。但由于这个地址是<strong>拷贝</strong>给了形参，因此仍然是值传递。</p>
<p>如何看出来这里是 <strong>拷贝</strong> 给了形参呢？再看下面这个例子：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        User han = new User();
        han.setName(&quot;Han Xiaojie&quot;);
        han.setAge(22);
        pass(han);
        System.out.println(&quot;In Main,user is &quot; + user);
    &#125;

    static void pass(User user) &#123;
        user = new User();
        user.setName(&quot;SkyFroop&quot;);
        System.out.println(&quot;In Pass,user is &quot; + user);
    &#125;
&#125;

class User &#123;
    private String name;
    private Integer age;
    /* 省略Setter/Getter和toString() */
&#125;
// ========================OUTPUT=============================
// In Pass,user is User&#123;name=&#39;SkyFroop&#39;, age=22&#125;
// In Main,user is User&#123;name=&#39;Han Xiaojie&#39;, age=22&#125;
</code></pre>
<p>这里的流程如下：</p>
<p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220315203254549.png" alt="image-20220315203254549"></p>
<p>new User()并没有对0x123456进行修改，而是又复制了一个 <strong>副本</strong>，开辟了一个新的空间。</p>
<p>因此可以完全得出结论：<strong>值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。</strong>在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。</p>
<h2 id="14-4-拓展"><a href="#14-4-拓展" class="headerlink" title="14.4  拓展"></a>14.4  拓展</h2><p>关于String，String是一个不可变类，从String的方法可以看到，所有对String的操作，都是在CopyOf一个新的String对象，如果尝试在pass中修改name，其实间接的创建了一个新的String对象，因此不会改变实参的值。</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2022 Hexo
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>